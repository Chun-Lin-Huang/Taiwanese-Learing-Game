import React, { useState, useEffect, useCallback } from 'react';
import { useNavigate, useLocation } from "react-router-dom";
import '../style/Monopoly.css';
import "../App.css";
import BackIcon from "../assets/Back.svg";
import { AudioManager, AudioType } from '../config/audioConfig';
import AudioControls from '../components/AudioControls';
import '../style/AudioControls.css';
import { MapApiService, type MapBoard } from '../services/mapApi';

interface PlayerRecord {
  id: number;
  timestamp: Date;
  location: string;
  locationName: string;
  action: string;
  details?: string;
}

interface Player {
  id: number;
  name: string;
  avatar: string;
  avatarImage?: string;
  round: number;
  status: string;
  location: string; // ä½ç½®å­—ç¬¦ä¸² (å¦‚ "S0", "A1", "B2")
  locationName: string; // ä½ç½®åç¨±
  record: string; // ä¿ç•™ç”¨æ–¼é¡¯ç¤ºæœ€æ–°è¨˜éŒ„
  records: PlayerRecord[]; // è©³ç´°è¨˜éŒ„æ•¸çµ„
  isCurrentPlayer: boolean;
  score: number; // ç©å®¶åˆ†æ•¸
  diceSum: number; // éª°å­é»æ•¸åŠ ç¸½
  userName?: string; // ä½¿ç”¨è€…åç¨±ï¼ˆå¾è³‡æ–™åº«æŸ¥è©¢å¾—åˆ°ï¼‰
  currency: number; // ç©å®¶è²¨å¹£
}

interface Property {
  id: number;
  name: string;
  type: 'property' | 'challenge' | 'chance' | 'start' | 'go' | 'special' | 'shortcut' | 'reward' | 'vocabulary';
  price?: number;
  rent?: number;
  description: string;
  color?: string;
  owner?: number; // æ“æœ‰è€…ID
  challenge?: {
    type: 'vocabulary' | 'culture' | 'story' | 'action' | 'train';
    title: string;
    content: string;
    reward: string;
  };
  chance?: {
    type: 'positive' | 'negative' | 'neutral';
    title: string;
    content: string;
    effect: string;
  };
  shortcut?: {
    target: number; // è·³è½‰åˆ°çš„ä½ç½®
    description: string;
  };
}

interface GameAction {
  id: string;
  timestamp: Date;
  playerId: number;
  playerName: string;
  actionType: 'dice_roll' | 'move' | 'challenge' | 'bankruptcy' | 'shortcut' | 'victory';
  description: string;
  details?: any;
}

interface GameHistory {
  gameId: string;
  startTime: Date;
  endTime?: Date;
  actions: GameAction[];
  players: Player[];
}

const Monopoly: React.FC = () => {
    const navigate = useNavigate();
    const location = useLocation();
    
    // åœ°åœ–è³‡æ–™ç‹€æ…‹
    const [mapBoard, setMapBoard] = useState<MapBoard | null>(null);
    const [isMapLoaded, setIsMapLoaded] = useState(false);
    
    // éŸ³æ•ˆç®¡ç†å™¨
    const audioManager = AudioManager.getInstance();
    const [showGameOver, setShowGameOver] = useState(false);
    const [winner, setWinner] = useState<Player | null>(null);
    const [showGameHistory, setShowGameHistory] = useState(false);
    const [showLocationDetail, setShowLocationDetail] = useState(false);
    const [currentLocationDetail, setCurrentLocationDetail] = useState<Property | null>(null);
  const [currentRound] = useState(1);
  const [playersInCurrentRound] = useState<number[]>([]);
  const [playersPassedStart, setPlayersPassedStart] = useState<{[playerId: number]: number}>({});
  const [showPassedStartCelebration, setShowPassedStartCelebration] = useState(false);
  const [passedStartMessage, setPassedStartMessage] = useState('');
    const [showCouponPanel, setShowCouponPanel] = useState(false);
    const [couponType, setCouponType] = useState<'property' | 'gas_station' | 'road_construction'>('property');
  const [showChallengePanel, setShowChallengePanel] = useState(false);
  const [currentChallenge, setCurrentChallenge] = useState<any>(null);
  const [selectedChallengeType] = useState<string | null>(null);
  const [challengeQuestion, setChallengeQuestion] = useState<string>('');
  const [playerAnswer, setPlayerAnswer] = useState<string>('');
  const [challengeResult, setChallengeResult] = useState<'success' | 'failure' | null>(null);
  
  // å„ªæƒ åˆ¸æŒ‘æˆ°ç¨ç«‹ç‹€æ…‹
  const [showCouponChallengePanel, setShowCouponChallengePanel] = useState(false);
  const [selectedCouponChallengeType, setSelectedCouponChallengeType] = useState<string | null>(null);
  const [couponChallengeQuestion, setCouponChallengeQuestion] = useState<string>('');
  const [couponPlayerAnswer, setCouponPlayerAnswer] = useState<string>('');
  const [couponChallengeResult, setCouponChallengeResult] = useState<'success' | 'failure' | null>(null);
  
  const [showWordCard, setShowWordCard] = useState(false);
  const [currentWordCard, setCurrentWordCard] = useState<any>(null);
  const [isDrawingCard, setIsDrawingCard] = useState(false);
  
  // STT ç›¸é—œç‹€æ…‹
  const [isRecording, setIsRecording] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [mediaRecorder, setMediaRecorder] = useState<MediaRecorder | null>(null);
  const [wordCardSTTResult, setWordCardSTTResult] = useState<string>('');
  const [wordCardChallengeResult, setWordCardChallengeResult] = useState<'success' | 'failure' | null>(null);
  
  // æƒ…å¢ƒå°è©±ç›¸é—œç‹€æ…‹
  const [scenarioSessionId, setScenarioSessionId] = useState<string | null>(null);
  const [scenarioMessages, setScenarioMessages] = useState<Array<{type: 'incoming' | 'outgoing', sender: string, content: string}>>([]);
  const [scenarioPlayerInput, setScenarioPlayerInput] = useState<string>('');
  const [scenarioIsProcessing, setScenarioIsProcessing] = useState(false);
  const [scenarioTopics, setScenarioTopics] = useState<Array<{_id: string, name: string}>>([]);
  
  // ä¸€èˆ¬æŒ‘æˆ°å°è©±ç›¸é—œç‹€æ…‹
  const [challengeSessionId] = useState<string | null>(null);
  const [challengeMessages, setChallengeMessages] = useState<Array<{type: 'incoming' | 'outgoing', sender: string, content: string}>>([]);
  const [challengeIsProcessing] = useState(false);
  
  // 17æŒ‘æˆ°æˆåŠŸå¾Œçš„ç‰¹æ®Šç§»å‹•è¦å‰‡
  const [o17ChallengeSuccessPlayers, setO17ChallengeSuccessPlayers] = useState<{[playerId: number]: boolean}>({});
  
  // è·¯å¾‘é¸æ“‡ç›¸é—œç‹€æ…‹
  const [showPathSelection, setShowPathSelection] = useState(false);
  const [pathOptions, setPathOptions] = useState<{
    normal: {new_position: string, position_info: any, path: string[]},
    alternative: {new_position: string, path: string[]}
  } | null>(null);
  
  
  // éŠæˆ²ä¸»é¡Œç‹€æ…‹
  const [gameTheme, setGameTheme] = useState<string>('traffic'); // é»˜èªä½¿ç”¨äº¤é€šä¸»é¡Œ
  const [showThemeSelection, setShowThemeSelection] = useState(true);
  const [selectedTheme, setSelectedTheme] = useState<string | null>(null);
  const [availableThemes, setAvailableThemes] = useState<Array<{id: string, name: string, key: string}>>([]);
  const [themesLoaded, setThemesLoaded] = useState(false);
  
  // ç«è»ŠæŒ‘æˆ°ç‹€æ…‹ - æ”¹ç‚ºæŒ‰ç©å®¶è¨˜éŒ„
  const [playerShortcutPrivileges, setPlayerShortcutPrivileges] = useState<{[playerId: number]: {canUseShortcut: boolean, nextMoveToShortcut: boolean}}>({});
  
  // æš«åœç‹€æ…‹
  const [playerSkipped, setPlayerSkipped] = useState<boolean>(false);
  // é“è·¯æ–½å·¥å°ˆç”¨æš«åœç‹€æ…‹
  const [roadConstructionSkip, setRoadConstructionSkip] = useState<{[playerId: number]: boolean}>({});
  // æš«åœæç¤ºè¦–çª—ç‹€æ…‹
  const [showSkipAlert, setShowSkipAlert] = useState(false);
  const [skipAlertMessage, setSkipAlertMessage] = useState('');
  // ç§»é™¤æœªä½¿ç”¨çš„ playerGameStarted ç‹€æ…‹ï¼ˆç¾åœ¨ç”± API è™•ç†ï¼‰

  // éŠæˆ²æ­·ç¨‹ç‹€æ…‹
  const [gameHistory, setGameHistory] = useState<GameHistory>({
    gameId: `game_${Date.now()}`,
    startTime: new Date(),
    actions: [],
    players: []
  });
  
  // éŠæˆ²æ˜¯å¦å·²åœ¨è³‡æ–™åº«ä¸­å‰µå»º
  const [isGameCreatedInDB, setIsGameCreatedInDB] = useState(false);

  // è¼‰å…¥æƒ…å¢ƒä¸»é¡Œ
  useEffect(() => {
    const loadScenarioTopics = async () => {
      try {
        const response = await fetch('http://127.0.0.1:2083/api/v1/chat-choose/list');
        const result = await response.json();
        if (result.code === 200 && result.body) {
          setScenarioTopics(result.body);
        }
      } catch (error) {
        console.error('è¼‰å…¥æƒ…å¢ƒä¸»é¡Œå¤±æ•—:', error);
      }
    };
    
    loadScenarioTopics();
  }, []);

  // åˆå§‹åŒ–ä¸»é¡Œè³‡æ–™
  useEffect(() => {
    const loadThemes = async () => {
      try {
        const response = await fetch('http://127.0.0.1:2083/api/v1/vocab-categories/list');
        const result = await response.json();
        
        if (result.code === 200 && result.body) {
          // åªé¡¯ç¤ºæŒ‡å®šçš„ä¸»é¡Œï¼šäº¤é€šå·¥å…·å’Œè·æ¥­èˆ‡ç¤¾æœƒè§’è‰²
          const targetThemes = result.body.filter((theme: any) => 
            theme.name === 'äº¤é€šå·¥å…·' || theme.name === 'è·æ¥­èˆ‡ç¤¾æœƒè§’è‰²'
          );
          
          const formattedThemes = targetThemes.map((theme: any) => ({
            id: theme._id,
            name: theme.name,
            key: theme.name === 'äº¤é€šå·¥å…·' ? 'traffic' : 'occupation'
          }));
          
          setAvailableThemes(formattedThemes);
          setThemesLoaded(true);
          console.log('ä¸»é¡Œè¼‰å…¥æˆåŠŸ:', formattedThemes);
        } else {
          console.error('ä¸»é¡Œè¼‰å…¥å¤±æ•—:', result.message);
          setThemesLoaded(true);
        }
      } catch (error) {
        console.error('è¼‰å…¥ä¸»é¡Œå¤±æ•—:', error);
        setThemesLoaded(true);
      }
    };

    loadThemes();
  }, []);

  // åˆå§‹åŒ–åœ°åœ–è³‡æ–™
  useEffect(() => {
    const initializeMap = async () => {
      try {
        // ä½¿ç”¨é ç¨‹è³‡æ–™åº«ä¸­çš„åœ°åœ– ID
        const boardId = '68c1d61f0b2c1d8e238edceb';
        
        // ç²å–åœ°åœ–å®Œæ•´è³‡è¨Š
        const mapInfo = await MapApiService.getMapInfo(boardId);
        
        if (mapInfo.code === 200 && mapInfo.body) {
          setMapBoard(mapInfo.body.board);
          setIsMapLoaded(true);
          console.log('åœ°åœ–è³‡æ–™è¼‰å…¥æˆåŠŸ:', mapInfo.body);
        } else {
          console.error('åœ°åœ–è³‡æ–™è¼‰å…¥å¤±æ•—:', mapInfo.message);
          // å¦‚æœ API å¤±æ•—ï¼Œä½¿ç”¨é è¨­è³‡æ–™
          setIsMapLoaded(true);
        }
      } catch (error) {
        console.error('åˆå§‹åŒ–åœ°åœ–å¤±æ•—:', error);
        // å¦‚æœ API å¤±æ•—ï¼Œä½¿ç”¨é è¨­è³‡æ–™
        setIsMapLoaded(true);
      }
    };

    initializeMap();
  }, []);

  // åˆå§‹åŒ–ç©å®¶æ•¸æ“šçš„å‡½æ•¸
  const initializePlayers = (playerNames: string[]): Player[] => {
    const avatars = ['ğŸ»', 'ğŸ¯', 'ğŸ˜', 'ğŸ±'];
    const avatarImages = [
      '/src/assets/å°ç†Šé ­.png',
      '/src/assets/å°è²“.png', 
      '/src/assets/è€è™.png',
      '/src/assets/å¤§è±¡.png'
    ];
    
    return playerNames.map((name, index) => ({
      id: index + 1,
      name: name,
      avatar: avatars[index] || 'ğŸ®',
      avatarImage: avatarImages[index] || '/src/assets/default.png',
      round: 0,
      status: 'æ­£å¸¸',
      location: 'S0', // å¾èµ·å§‹é»é–‹å§‹
      locationName: 'S0',
      record: 'æº–å‚™é–‹å§‹',
      records: [{
        id: 1,
        timestamp: new Date(),
        location: 'S0',
        locationName: 'S0',
        action: 'éŠæˆ²é–‹å§‹',
        details: 'æº–å‚™é–‹å§‹éŠæˆ²'
      }],
      isCurrentPlayer: index === 0, // ç¬¬ä¸€å€‹ç©å®¶æ˜¯ç•¶å‰ç©å®¶
      score: 0,
      diceSum: 0,
      currency: 1000, // åˆå§‹è²¨å¹£
    }));
  };

  // å¾location stateç²å–ç©å®¶æ•¸æ“šï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨é»˜èªå€¼
  const playerNames = location.state?.players || ['å½Œè±†å­', 'å°è²“å’ª', 'è€è™ç‹', 'å¤§è±¡å“¥'];
  
  // ç©å®¶ç‹€æ…‹ - å‹•æ…‹ç®¡ç†
  const [players, setPlayers] = useState<Player[]>(() => initializePlayers(playerNames));

  const currentPlayer = players.find(player => player.isCurrentPlayer);
  const diceValues = [3, 5, 1, 6, 2, 4]; // éš¨æ©Ÿéª°å­å€¼

  // æ·»åŠ ç©å®¶è¨˜éŒ„çš„å‡½æ•¸
  const addPlayerRecord = (playerId: number, location: string, locationName: string, action: string, details?: string) => {
    setPlayers(prevPlayers => 
      prevPlayers.map(player => {
        if (player.id === playerId) {
          const newRecord: PlayerRecord = {
            id: player.records.length + 1,
            timestamp: new Date(),
            location,
            locationName,
            action,
            details
          };
          return {
            ...player,
            records: [...player.records, newRecord],
            record: `${action} - ${locationName}` // æ›´æ–°æœ€æ–°è¨˜éŒ„é¡¯ç¤º
          };
        }
        return player;
      })
    );
  };

  // è¨˜éŒ„éŠæˆ²å‹•ä½œçš„å‡½æ•¸
  const recordGameAction = async (
    playerId: number, 
    playerName: string, 
    actionType: GameAction['actionType'], 
    description: string, 
    details?: any
  ) => {
    const newAction: GameAction = {
      id: `action_${Date.now()}_${Math.random()}`,
      timestamp: new Date(),
      playerId,
      playerName,
      actionType,
      description,
      details
    };

    // æ›´æ–°å‰ç«¯ç‹€æ…‹
    setGameHistory(prev => ({
      ...prev,
      actions: [...prev.actions, newAction]
    }));

    // å¦‚æœéŠæˆ²é‚„æ²’æœ‰åœ¨è³‡æ–™åº«ä¸­å‰µå»ºï¼Œå…ˆå‰µå»ºéŠæˆ²
    if (!isGameCreatedInDB) {
      try {
        const gameData = {
          gameId: gameHistory.gameId,
          gameName: gameTheme || 'å¤§å¯Œç¿éŠæˆ²',
          boardId: mapBoard?._id || '',
          players: players.map(p => ({
            id: p.id,
            name: p.name,
            userName: p.userName
          }))
        };

        const response = await fetch('http://127.0.0.1:2083/api/v1/game-history/create', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(gameData),
        });

        if (response.ok) {
          setIsGameCreatedInDB(true);
          console.log('éŠæˆ²è¨˜éŒ„å·²å‰µå»ºåˆ°è³‡æ–™åº«');
        } else {
          console.error('å‰µå»ºéŠæˆ²è¨˜éŒ„å¤±æ•—:', await response.text());
        }
      } catch (error) {
        console.error('å‰µå»ºéŠæˆ²è¨˜éŒ„æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
      }
    }

    // ä¿å­˜å‹•ä½œåˆ°è³‡æ–™åº«
    if (isGameCreatedInDB) {
      try {
        const actionData = {
          actionType: newAction.actionType,
          playerId: newAction.playerId,
          playerName: newAction.playerName,
          description: newAction.description,
          details: newAction.details,
          timestamp: newAction.timestamp.toISOString()
        };

        const response = await fetch(`http://127.0.0.1:2083/api/v1/game-history/${gameHistory.gameId}/action`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(actionData),
        });

        if (!response.ok) {
          console.error('ä¿å­˜éŠæˆ²å‹•ä½œå¤±æ•—:', await response.text());
        }
      } catch (error) {
        console.error('ä¿å­˜éŠæˆ²å‹•ä½œæ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
      }
    }
  };

  // çµæŸéŠæˆ²ä¸¦ä¿å­˜åˆ°è³‡æ–™åº«
  const endGameInDatabase = async (winner?: { playerId: number; playerName: string; reason: string }) => {
    if (!isGameCreatedInDB) return;

    try {
      const finalPlayers = players.map(p => ({
        id: p.id,
        finalScore: p.currency,
        finalRound: p.round
      }));

      const response = await fetch(`http://127.0.0.1:2083/api/v1/game-history/${gameHistory.gameId}/end`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          winner,
          finalPlayers
        }),
      });

      if (response.ok) {
        console.log('éŠæˆ²çµæŸè¨˜éŒ„å·²ä¿å­˜åˆ°è³‡æ–™åº«');
      } else {
        console.error('ä¿å­˜éŠæˆ²çµæŸè¨˜éŒ„å¤±æ•—:', await response.text());
      }
    } catch (error) {
      console.error('ä¿å­˜éŠæˆ²çµæŸè¨˜éŒ„æ™‚ç™¼ç”ŸéŒ¯èª¤:', error);
    }
  };

  // è™•ç†è·¯å¾‘é¸æ“‡
  const handlePathSelection = (selectedPath: 'normal' | 'alternative') => {
    if (!pathOptions) return;
    
    const selectedOption = selectedPath === 'normal' ? pathOptions.normal : pathOptions.alternative;
    const currentPlayer = players.find(p => p.isCurrentPlayer);
    if (!currentPlayer) return;
    
    console.log('ç©å®¶é¸æ“‡è·¯å¾‘:', selectedPath, selectedOption);
    console.log('selectedOption çµæ§‹:', {
      normal: pathOptions.normal,
      alternative: pathOptions.alternative,
      selectedOption
    });

    // æ’­æ”¾éª°å­éŸ³æ•ˆ
    audioManager.play(AudioType.THEME_SELECTION, 0.2);

    // è¨˜éŒ„ç§»å‹•å‹•ä½œ
      recordGameAction(
        currentPlayer.id,
        currentPlayer.name,
      'move',
      `${currentPlayer.name} é¸æ“‡${selectedPath === 'normal' ? 'æ­£å¸¸' : 'D5'}è·¯å¾‘ç§»å‹•åˆ° ${selectedOption.new_position}`,
      {
        path: selectedPath,
        newPosition: selectedOption.new_position,
        details: `é¸æ“‡${selectedPath === 'normal' ? 'æ­£å¸¸' : 'D5'}è·¯å¾‘ï¼Œç§»å‹•åˆ°${selectedOption.new_position}`
      }
    );
    
    // æ›´æ–°ç©å®¶ä½ç½®
      setPlayers(prevPlayers => 
      prevPlayers.map(player => {
        if (player.id === currentPlayer.id) {
          return {
                ...player,
            locationName: selectedOption.new_position,
            location: selectedOption.new_position,
            record: `${selectedOption.new_position} - è·¯å¾‘é¸æ“‡ç§»å‹•å®Œæˆ`
          };
        }
        return player;
      })
    );
    
    // å¦‚æœé¸æ“‡äº†D5è·¯å¾‘ï¼Œæ¸…é™¤17æŒ‘æˆ°æˆåŠŸè¨˜éŒ„
    if (selectedPath === 'alternative') {
      console.log('ç©å®¶é¸æ“‡D5è·¯å¾‘ï¼Œæ¸…é™¤17æŒ‘æˆ°æˆåŠŸè¨˜éŒ„');
      setO17ChallengeSuccessPlayers(prev => {
        const newState = { ...prev };
        delete newState[currentPlayer.id];
        return newState;
      });
    }
    
    // ç²å–ä½ç½®ä¿¡æ¯ä¸¦è™•ç†å¾ŒçºŒäº‹ä»¶
    console.log('æº–å‚™ç²å–ä½ç½®ä¿¡æ¯:', selectedOption.new_position);
    fetchPositionInfo(selectedOption.new_position);
    
    // æ¸…é™¤è·¯å¾‘é¸æ“‡ç‹€æ…‹
    setShowPathSelection(false);
    setPathOptions(null);
  };

  // ç²å–ä½ç½®ä¿¡æ¯ä¸¦è™•ç†äº‹ä»¶
  const fetchPositionInfo = async (positionId: string) => {
    try {
      console.log('fetchPositionInfo è¢«èª¿ç”¨ï¼ŒpositionId:', positionId, 'boardId:', mapBoard?._id);
      if (!mapBoard?._id) {
        console.error('æ²’æœ‰åœ°åœ–IDï¼Œç„¡æ³•ç²å–ä½ç½®ä¿¡æ¯');
        return;
      }
      const positionResult = await MapApiService.getNodeById(positionId, mapBoard._id);
      console.log('ä½ç½®ä¿¡æ¯ç²å–çµæœ:', positionResult);
      if (positionResult.code === 200 && positionResult.body) {
        const position_info = positionResult.body;
        
        // è™•ç†ä½ç½®äº‹ä»¶
        handleLocationEvent(position_info);
      }
    } catch (error) {
      console.error('ç²å–ä½ç½®ä¿¡æ¯å¤±æ•—:', error);
    }
  };

  // è™•ç†éª°å­é»æ“Š - ç©å®¶å¯¦é«”æ“²éª°å­å¾Œé»æ“Šå°æ‡‰æ•¸å­—
  const handleDiceClick = async (value: number) => {
    if (!currentPlayer || !mapBoard) return;

    try {
      // ä½¿ç”¨ API è¨ˆç®—ç§»å‹•
      const moveRequest = {
        board_id: mapBoard._id,
        player_id: currentPlayer.id.toString(),
        current_position: currentPlayer.locationName,
        dice_value: value,
        // æª¢æŸ¥æ˜¯å¦æœ‰17æŒ‘æˆ°æˆåŠŸè¨˜éŒ„
        o17_challenge_success: o17ChallengeSuccessPlayers[currentPlayer.id] || false
      };
      
      console.log('ç•¶å‰ç©å®¶ä½ç½®:', currentPlayer.locationName, 'é¡å‹:', typeof currentPlayer.locationName);
      
      console.log('ç§»å‹•è«‹æ±‚:', moveRequest);

      const moveResult = await MapApiService.calculateMove(moveRequest);
      
      console.log('ç§»å‹•çµæœ:', moveResult);
      
      if (moveResult.code === 200 && moveResult.body) {
        const { new_position, position_info, passed_start, alternative_path } = moveResult.body;

        // å¦‚æœæœ‰alternative_pathï¼Œé¡¯ç¤ºè·¯å¾‘é¸æ“‡
        if (alternative_path) {
          console.log('æœ‰D5è·¯å¾‘é¸é …ï¼Œé¡¯ç¤ºè·¯å¾‘é¸æ“‡');
          setPathOptions({
            normal: {
              new_position,
              position_info,
              path: [currentPlayer.locationName, new_position]
            },
            alternative: alternative_path
          });
          setShowPathSelection(true);
          return; // ç­‰å¾…ç©å®¶é¸æ“‡è·¯å¾‘
        }

    // æ’­æ”¾éª°å­éŸ³æ•ˆ
        audioManager.play(AudioType.THEME_SELECTION, 0.2);

    // è¨˜éŒ„æ“²éª°å­å‹•ä½œ
        recordGameAction(
          currentPlayer.id,
          currentPlayer.name,
      'dice_roll',
      `${currentPlayer.name} æ“²å‡º ${value} é»`,
          { diceValue: value, location: currentPlayer.locationName }
        );

        // æ›´æ–°ç©å®¶ä½ç½®
      setPlayers(prevPlayers => 
          prevPlayers.map(player => {
            if (player.id === currentPlayer.id) {
              const updatedPlayer = {
                ...player,
                locationName: new_position,
                location: position_info.node_id, // ä½¿ç”¨ç¯€é»IDä½œç‚ºä½ç½®
                record: `${position_info.name} - ç§»å‹•å®Œæˆ`
              };
              console.log(`${player.name} ä½ç½®æ›´æ–°:`, {
                å¾: player.locationName,
                åˆ°: updatedPlayer.locationName,
                ä½ç½®ID: updatedPlayer.location
              });
              return updatedPlayer;
            }
            return player;
          })
        );

        // æª¢æŸ¥æ˜¯å¦ç¶“éèµ·é»ï¼Œä¸¦æ›´æ–°ç¶“éæ¬¡æ•¸å’Œå›åˆæ•¸
        if (passed_start) {
          const currentPlayerId = currentPlayer.id;
          setPlayersPassedStart(prev => {
            const newCount = (prev[currentPlayerId] || 0) + 1;
            console.log(`${currentPlayer.name} ç¶“éèµ·é»ï¼Œç¬¬ ${newCount} æ¬¡`);
            
            // é¡¯ç¤ºç¶“éèµ·é»æ…¶ç¥è¦–çª—
            setPassedStartMessage(`${currentPlayer.name} ç¶“éèµ·é»ï¼ç¬¬ ${newCount} æ¬¡`);
            setShowPassedStartCelebration(true);
            
            // 3ç§’å¾Œè‡ªå‹•é—œé–‰æ…¶ç¥è¦–çª—
            setTimeout(() => {
              setShowPassedStartCelebration(false);
            }, 3000);
            
            // æª¢æŸ¥æ˜¯å¦ç²å‹ï¼ˆç¶“éèµ·é»3æ¬¡ï¼‰
            if (newCount >= 3) {
              setWinner(currentPlayer);
      recordGameAction(
        currentPlayer.id,
        currentPlayer.name,
                'victory',
                `${currentPlayer.name} ç¶“éèµ·é»3æ¬¡ï¼Œç²å¾—å‹åˆ©ï¼`,
                { winner: true, passedStartCount: newCount }
              );
              
            setTimeout(async () => {
                setShowGameOver(true);
                // çµæŸéŠæˆ²ä¸¦ä¿å­˜åˆ°è³‡æ–™åº«
                await endGameInDatabase({
                  playerId: currentPlayer.id,
                  playerName: currentPlayer.name,
                  reason: 'ç¶“éèµ·é»3æ¬¡'
                });
              }, 1000);
          }
          
            return {
          ...prev,
              [currentPlayerId]: newCount
            };
          });
          
          // æ›´æ–°ç©å®¶å›åˆæ•¸
          setPlayers(prev => prev.map(player => {
            if (player.id === currentPlayerId) {
              return {
                ...player,
                round: player.round + 1
              };
            }
            return player;
          }));
        }

        // è¨˜éŒ„ç§»å‹•å‹•ä½œ
      recordGameAction(
        currentPlayer.id,
        currentPlayer.name,
        'move',
          `${currentPlayer.name} ç§»å‹•åˆ°ï¼š${position_info.name}`,
          { 
            from: currentPlayer.locationName, 
            to: new_position, 
            propertyType: position_info.type,
            property: position_info
          }
      );

      // æ·»åŠ ç©å®¶è¨˜éŒ„
      addPlayerRecord(
        currentPlayer.id,
        position_info.node_id, 
        position_info.name, 
        'ç§»å‹•åˆ°', 
        `æ“²å‡º${value}é»ï¼Œç§»å‹•åˆ°${position_info.name}`
      );

        // æ ¹æ“šæ ¼å­é¡å‹è™•ç†å¾ŒçºŒäº‹ä»¶
        handleLocationEvent(position_info);
        
          } else {
        console.error('ç§»å‹•è¨ˆç®—å¤±æ•—:', moveResult.message);
        // å¦‚æœ API å¤±æ•—ï¼Œå¯ä»¥å›é€€åˆ°åŸä¾†çš„é‚è¼¯æˆ–é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
      }
    } catch (error) {
      console.error('è™•ç†ç§»å‹•å¤±æ•—:', error);
      // å¦‚æœ API å¤±æ•—ï¼Œå¯ä»¥å›é€€åˆ°åŸä¾†çš„é‚è¼¯æˆ–é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
    }
  };

  // è™•ç†ä½ç½®äº‹ä»¶çš„å‡½æ•¸
  const handleLocationEvent = (positionInfo: any) => {
    if (!positionInfo) return;

    console.log('è™•ç†ä½ç½®äº‹ä»¶:', {
      node_id: positionInfo.node_id,
      name: positionInfo.name,
      type: positionInfo.type,
      challenge_type: positionInfo.challenge?.type
    });

      // æ ¹æ“šæ ¼å­é¡å‹é¡¯ç¤ºä¸åŒçš„è¦–çª—
    if (positionInfo.type === 'property') {
        // åœ°ç”¢æ ¼å­é¡¯ç¤ºå„ªæƒ åˆ¸è¦–çª—
        setCouponType('property');
        setShowCouponPanel(true);
    } else if (positionInfo.name === 'åŠ æ²¹ç«™') {
        // åŠ æ²¹ç«™é¡¯ç¤ºå„ªæƒ åˆ¸è¦–çª—
        setCouponType('gas_station');
        setShowCouponPanel(true);
    } else if (positionInfo.type === 'stop') {
        // stop é¡å‹æ ¼å­ç›´æ¥æš«åœä¸€å›åˆï¼Œä¸é¡¯ç¤ºå„ªæƒ åˆ¸
        const currentPlayer = players.find(p => p.isCurrentPlayer);
        if (currentPlayer) {
          setRoadConstructionSkip(prev => ({
            ...prev,
            [currentPlayer.id]: true
          }));
          
          recordGameAction(
            currentPlayer.id,
            currentPlayer.name,
            'move',
            `${currentPlayer.name} åœ¨${positionInfo.name}æš«åœä¸€å›åˆ`,
            { location: currentPlayer.location, skipped: true, positionType: 'stop' }
          );
          
          // é¡¯ç¤ºæš«åœæç¤º
          setSkipAlertMessage(`${currentPlayer.name} åœ¨${positionInfo.name}æš«åœä¸€å›åˆ`);
          setShowSkipAlert(true);
          
          // ç›´æ¥åˆ‡æ›åˆ°ä¸‹ä¸€ä½ç©å®¶
          setTimeout(() => {
            setShowSkipAlert(false);
            switchToNextPlayer();
          }, 2000);
        }
    } else if (positionInfo.type === 'challenge' || positionInfo.type === 'vocabulary') {
        // æª¢æŸ¥æ˜¯å¦ç‚º"ä¾†å­¸å–®å­—"æ ¼å­
      if (positionInfo.challenge?.type === 'vocabulary' || positionInfo.type === 'vocabulary') {
          // ä¾†å­¸å–®å­—æ ¼å­è§¸ç™¼å–®å­—å¡ç‰‡
          setIsDrawingCard(true);
          
          // æŠ½å¡ç‰‡å‹•ç•«æ•ˆæœ
        setTimeout(async () => {
          try {
            // æ ¹æ“šéŠæˆ²ä¸»é¡Œç²å–å°æ‡‰çš„åˆ†é¡ ID
            const categoryId = gameTheme === 'traffic' 
              ? '6894ec12e4c25617b65cd248' // äº¤é€šå·¥å…·åˆ†é¡ ID
              : gameTheme === 'occupation' 
              ? '6894ec12e4c25617b65cd25c' // è·æ¥­èˆ‡ç¤¾æœƒè§’è‰²åˆ†é¡ ID
              : '6894ec12e4c25617b65cd248'; // é è¨­ä½¿ç”¨äº¤é€šå·¥å…·
            
            // ä½¿ç”¨åŸæœ¬çš„ API ç²å–å–®å­—å¡ç‰‡
            const response = await fetch(`http://127.0.0.1:2083/api/v1/vocab-cards/by-category/${categoryId}`);
            const result = await response.json();
            
            if (result.code === 200 && result.body && result.body.length > 0) {
              const randomIndex = Math.floor(Math.random() * result.body.length);
              const selectedCard = result.body[randomIndex];
              
              console.log('å¾ API ç²å–çš„å–®å­—å¡ç‰‡:', selectedCard);
              
              // ç²å–å°æ‡‰çš„åœ–ç‰‡
              try {
                const imageResponse = await fetch(`http://127.0.0.1:2083/api/v1/vocabulary-pictures/by-card/${selectedCard._id}`);
                const imageResult = await imageResponse.json();
                
                if (imageResult.code === 200 && imageResult.body) {
                  selectedCard.image = imageResult.body.imageUrl;
                  console.log('ç²å–åœ–ç‰‡æˆåŠŸ:', imageResult.body.imageUrl);
                } else {
                  console.log('è©²å–®å­—å¡ç‰‡æ²’æœ‰å°æ‡‰çš„åœ–ç‰‡');
                  selectedCard.image = null;
                }
              } catch (imageError) {
                console.error('ç²å–åœ–ç‰‡å¤±æ•—:', imageError);
                selectedCard.image = null;
              }
              
            setCurrentWordCard(selectedCard);
            setIsDrawingCard(false);
            setShowWordCard(true);
            
            // è¨˜éŒ„éŠæˆ²å‹•ä½œ
            const currentPlayer = players.find(p => p.isCurrentPlayer);
            if (currentPlayer) {
              recordGameAction(
                currentPlayer.id,
                currentPlayer.name,
                'challenge',
                  `ä¾†å­¸å–®å­—å¡ç‰‡: ${selectedCard.han}`,
                  { cardId: selectedCard._id, category: selectedCard.categoryId, theme: gameTheme }
                );
              }
            } else {
              console.error('æ²’æœ‰å¯ç”¨çš„å–®å­—å¡ç‰‡ï¼', result);
              setIsDrawingCard(false);
            }
          } catch (error) {
            console.error('ç²å–å–®å­—å¡ç‰‡å¤±æ•—:', error);
            setIsDrawingCard(false);
            }
          }, 2000); // 2ç§’æŠ½å¡ç‰‡å‹•ç•«
      } else if (positionInfo.challenge?.type === 'train') {
        // ç«è»ŠæŒ‘æˆ°æ ¼å­
        setCurrentChallenge(positionInfo.challenge);
          setShowChallengePanel(true);
        } else {
          // å…¶ä»–æŒ‘æˆ°æ ¼å­é¡¯ç¤ºæŒ‘æˆ°å´é‚Šé¢æ¿
        setCurrentChallenge(positionInfo.challenge);
          setShowChallengePanel(true);
        }
      } else {
        // å…¶ä»–æ ¼å­é¡¯ç¤ºä½ç½®è©³æƒ…
        setCurrentLocationDetail(positionInfo);
        setShowLocationDetail(true);
        
        // åªæœ‰éæ©Ÿæœƒæ ¼ã€éçå‹µæ ¼ã€éèµ·é»æ ¼æ‰è‡ªå‹•åˆ‡æ›åˆ°ä¸‹ä¸€å€‹ç©å®¶
        if (positionInfo.type !== 'chance' && positionInfo.type !== 'reward' && positionInfo.type !== 'start') {
          // è‡ªå‹•åˆ‡æ›åˆ°ä¸‹ä¸€å€‹ç©å®¶
          setTimeout(() => {
            switchToNextPlayer();
          }, 1000); // 1ç§’å¾Œè‡ªå‹•åˆ‡æ›
      }
    }
  };

  // åˆ‡æ›åˆ°ä¸‹ä¸€ç©å®¶
  const switchToNextPlayer = () => {
    setPlayers(prevPlayers => {
      const currentIndex = prevPlayers.findIndex(p => p.isCurrentPlayer);
      const currentPlayer = prevPlayers[currentIndex];
      let nextIndex = (currentIndex + 1) % prevPlayers.length;
      
      console.log('è¼ªæ›ç©å®¶:', {
        currentPlayer: currentPlayer?.name,
        nextPlayer: prevPlayers[nextIndex]?.name,
        currentIndex,
        nextIndex,
        playerSkipped,
        roadConstructionSkip,
        currentRound,
        playersInCurrentRound
      });
      
      // å¦‚æœç•¶å‰ç©å®¶è¢«æš«åœï¼Œè·³éä¸€æ¬¡
      if (playerSkipped) {
        setPlayerSkipped(false); // é‡ç½®æš«åœç‹€æ…‹
        return prevPlayers.map((player, index) => ({
          ...player,
          isCurrentPlayer: index === nextIndex
        }));
      }
      
      // æª¢æŸ¥ä¸‹ä¸€å€‹ç©å®¶æ˜¯å¦æœ‰é“è·¯æ–½å·¥æš«åœç‹€æ…‹
      const nextPlayer = prevPlayers[nextIndex];
      if (nextPlayer && roadConstructionSkip[nextPlayer.id]) {
        // é¡¯ç¤ºæš«åœæç¤ºè¦–çª—
        setSkipAlertMessage(`${nextPlayer.name} å› é“è·¯æ–½å·¥æš«åœä¸€å›åˆï¼Œæ›ä¸‹ä¸€ä½ç©å®¶`);
        setShowSkipAlert(true);
        
        // è¨˜éŒ„è·³éå‹•ä½œ
        recordGameAction(
          nextPlayer.id,
          nextPlayer.name,
          'move',
          `${nextPlayer.name} å› é“è·¯æ–½å·¥æš«åœï¼Œæœ¬æ¬¡è¼ªåˆ°è¢«è·³é`,
          { skipped: true, roadConstructionSkip: true }
        );
        
        // è·³éé€™å€‹ç©å®¶ï¼Œåˆ°ä¸‹ä¸‹ä¸€å€‹
        nextIndex = (nextIndex + 1) % prevPlayers.length;
        
        // æ¸…é™¤è©²ç©å®¶çš„é“è·¯æ–½å·¥æš«åœç‹€æ…‹
        setRoadConstructionSkip(prev => {
          const newState = { ...prev };
          delete newState[nextPlayer.id];
          return newState;
        });
      }
      
      // ç°¡åŒ–è¼ªæ›é‚è¼¯ï¼šç›´æ¥åˆ‡æ›åˆ°ä¸‹ä¸€å€‹ç©å®¶ï¼Œä¸ç®¡ç†è¤‡é›œçš„å›åˆæ•¸
      console.log('ç›´æ¥åˆ‡æ›åˆ°ä¸‹ä¸€å€‹ç©å®¶');
      return prevPlayers.map((player, index) => ({
        ...player,
        isCurrentPlayer: index === nextIndex
      }));
    });
  };

  // æ›´æ–°ç©å®¶ç‹€æ…‹
  const updatePlayerStatus = (playerId: number, updates: Partial<Player>) => {
    setPlayers(prevPlayers => 
      prevPlayers.map(player => 
        player.id === playerId 
          ? { ...player, ...updates }
          : player
      )
    );
  };

  // è™•ç†ç ´ç”¢
  const handleBankruptcy = async () => {
    if (currentPlayer) {
      // æ’­æ”¾éŠæˆ²çµæŸéŸ³æ•ˆ
      audioManager.play(AudioType.VIEW_SCORE, 0.7);
      recordGameAction(
        currentPlayer.id,
        currentPlayer.name,
        'bankruptcy',
        `${currentPlayer.name} é¸æ“‡ç ´ç”¢`,
        { location: currentPlayer.location, round: currentPlayer.round }
      );
      
      // æ›´æ–°ç©å®¶ç‹€æ…‹ç‚ºç ´ç”¢
      updatePlayerStatus(currentPlayer.id, {
        status: 'ç ´ç”¢',
        record: 'éŠæˆ²çµæŸ - ç ´ç”¢'
      });
      
      // åˆ‡æ›åˆ°ä¸‹ä¸€ç©å®¶
      switchToNextPlayer();
    }
    // ç ´ç”¢æ™‚ä¸è¨­ç½®ç²å‹è€…ï¼Œç›´æ¥é¡¯ç¤ºéŠæˆ²çµæŸ
    setWinner(null);
    setShowGameOver(true);
    
    // çµæŸéŠæˆ²ä¸¦ä¿å­˜åˆ°è³‡æ–™åº«ï¼ˆç„¡ç²å‹è€…ï¼‰
    await endGameInDatabase();
  };


  // è™•ç†æŒ‘æˆ°å®Œæˆ
  const handleChallengeComplete = (challengeType: string, reward: string) => {
    if (!currentPlayer) return;
    
    recordGameAction(
      currentPlayer.id,
      currentPlayer.name,
      'challenge',
      `${currentPlayer.name} å®Œæˆ ${challengeType} æŒ‘æˆ°`,
      { challengeType, reward }
    );
    
    updatePlayerStatus(currentPlayer.id, {
      record: `${challengeType} æŒ‘æˆ°å®Œæˆ - ${reward}`
    });
  };

  // è™•ç†æŒ‘æˆ°ä¸»é¡Œé¸æ“‡ - ç›´æ¥ä½¿ç”¨æƒ…å¢ƒæŒ‘æˆ°é‚è¼¯
  const handleChallengeTypeSelect = async () => {
    if (!gameTheme) return;
    
    // æ’­æ”¾é–‹å§‹æŒ‘æˆ°éŸ³æ•ˆ
    audioManager.play(AudioType.START_CHALLENGE, 0.6);
    
    // ç›´æ¥ä½¿ç”¨æƒ…å¢ƒæŒ‘æˆ°çš„è®Šæ•¸ï¼Œè¨­ç½®ç‚º 'scenario'
    setSelectedCouponChallengeType('scenario');
    setChallengeResult(null);
    setPlayerAnswer('');
    
    // ç›´æ¥èª¿ç”¨æƒ…å¢ƒæŒ‘æˆ°çš„å•Ÿå‹•å‡½æ•¸
    await handleStartChallengeScenario();
  };

  // å•Ÿå‹•æŒ‘æˆ°æƒ…å¢ƒå°è©±ï¼ˆç›´æ¥ä½¿ç”¨æƒ…å¢ƒæŒ‘æˆ°é‚è¼¯ï¼‰
  const handleStartChallengeScenario = async () => {
    try {
      console.log('å•Ÿå‹•æŒ‘æˆ°æƒ…å¢ƒå°è©±ï¼ŒéŠæˆ²ä¸»é¡Œ:', gameTheme);
      
      // ç²å–æƒ…å¢ƒä¸»é¡Œåˆ—è¡¨
      const response = await fetch('http://127.0.0.1:2083/api/v1/chat-choose/list');
      const result = await response.json();
      
      if (result.code === 200 && result.body) {
        // æ ¹æ“šéŠæˆ²ä¸»é¡Œé¸æ“‡å°æ‡‰çš„æƒ…å¢ƒä¸»é¡Œ
        let selectedTopic = null;
        
        if (gameTheme === 'traffic') {
          selectedTopic = result.body.find((topic: any) => topic.name === 'äº¤é€šå·¥å…·');
        } else if (gameTheme === 'occupation') {
          selectedTopic = result.body.find((topic: any) => topic.name === 'è·æ¥­èˆ‡ç¤¾æœƒè§’è‰²');
        }
        
        if (selectedTopic) {
          console.log('é¸æ“‡çš„æŒ‘æˆ°æƒ…å¢ƒä¸»é¡Œ:', selectedTopic.name, 'éŠæˆ²ä¸»é¡Œ:', gameTheme);
          
          const userId = localStorage.getItem('userId') || 'default_user';
          
          // é–‹å§‹æŒ‘æˆ°æƒ…å¢ƒå°è©±ï¼ˆä½¿ç”¨æƒ…å¢ƒæŒ‘æˆ°çš„é‚è¼¯ï¼‰
          const response = await fetch('http://127.0.0.1:2083/api/v1/scenario/start', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              chatChooseId: selectedTopic._id,
              userId: userId
            })
          });
          
          const startResult = await response.json();
          
          if (startResult.code === 200 && startResult.body) {
            console.log('è¨­ç½® scenarioSessionId:', startResult.body.session_id);
            
            // ç›´æ¥ä½¿ç”¨æƒ…å¢ƒæŒ‘æˆ°çš„è®Šæ•¸
            setScenarioSessionId(startResult.body.session_id);
            setScenarioMessages([{
              type: 'incoming',
              sender: 'å°ç†Š',
              content: startResult.body.npc_text || 'æ­¡è¿ä¾†åˆ°æŒ‘æˆ°ï¼è®“æˆ‘å€‘é–‹å§‹å°è©±å§ï¼'
            }]);
            
            console.log('æŒ‘æˆ°æƒ…å¢ƒå°è©±å•Ÿå‹•æˆåŠŸ:', startResult.body);
            console.log('ç‹€æ…‹è¨­ç½®å®Œæˆï¼ŒscenarioSessionId æ‡‰è©²ç‚º:', startResult.body.session_id);
          } else {
            console.error('å•Ÿå‹•æŒ‘æˆ°æƒ…å¢ƒå°è©±å¤±æ•—:', startResult);
          }
        } else {
          console.error('æ‰¾ä¸åˆ°å°æ‡‰çš„æŒ‘æˆ°æƒ…å¢ƒä¸»é¡Œ');
        }
      } else {
        console.error('ç²å–æŒ‘æˆ°æƒ…å¢ƒä¸»é¡Œå¤±æ•—:', result);
      }
    } catch (error) {
      console.error('å•Ÿå‹•æŒ‘æˆ°æƒ…å¢ƒå°è©±éŒ¯èª¤:', error);
    }
  };

  // è™•ç†ç©å®¶ç­”æ¡ˆæäº¤
  const handleAnswerSubmit = () => {
    if (!selectedChallengeType || !playerAnswer.trim()) return;
    
    let isCorrect = false;
    
    // ä½¿ç”¨ currentWordCard ä¾†åˆ¤æ–·ç­”æ¡ˆï¼ˆAPIç²å–çš„å–®å­—å¡ï¼‰
    if (currentWordCard) {
      isCorrect = playerAnswer === currentWordCard.ch || playerAnswer === currentWordCard.han;
      console.log(`æŒ‘æˆ°ç­”æ¡ˆåˆ¤æ–· (APIå–®å­—å¡): "${playerAnswer}" vs ä¸­æ–‡"${currentWordCard.ch}" æˆ– å°èª"${currentWordCard.han}" = ${isCorrect ? 'æ­£ç¢º' : 'éŒ¯èª¤'}`);
    } else {
      console.warn('æ²’æœ‰å¯ç”¨çš„å–®å­—å¡ç‰‡ä¾†åˆ¤æ–·ç­”æ¡ˆ');
      isCorrect = false;
    }
    
    if (isCorrect !== undefined) {
      
      setChallengeResult(isCorrect ? 'success' : 'failure');
      
      // æ’­æ”¾æŒ‘æˆ°çµæœéŸ³æ•ˆ
      if (isCorrect) {
        audioManager.play(AudioType.CORRECT_ANSWER, 0.6);
      } else {
        audioManager.play(AudioType.WRONG_ANSWER, 0.6);
      }
      
      // æª¢æŸ¥æ˜¯å¦ç‚ºç«è»ŠæŒ‘æˆ°
      if (currentChallenge?.type === 'train') {
        const currentPlayer = players.find(p => p.isCurrentPlayer);
        if (currentPlayer) {
          setPlayerShortcutPrivileges(prev => ({
            ...prev,
            [currentPlayer.id]: {
              canUseShortcut: isCorrect,
              nextMoveToShortcut: isCorrect // å¦‚æœæŒ‘æˆ°æˆåŠŸï¼Œè¨­ç½®ä¸‹ä¸€æ¬¡ç§»å‹•åˆ°æ·å¾‘
            }
          }));
        }
        
        // è¨˜éŒ„ç«è»ŠæŒ‘æˆ°çµæœ
        if (currentPlayer) {
          recordGameAction(
            currentPlayer.id,
            currentPlayer.name,
            'challenge',
            `ç«è»ŠæŒ‘æˆ°${isCorrect ? 'æˆåŠŸ' : 'å¤±æ•—'}: ${challengeQuestion} - ${isCorrect ? 'ä¸‹ä¸€æ¬¡ç§»å‹•å°‡åœ¨æ·å¾‘è·¯ç·š(36-41)' : 'æœ¬æ¬¡ä¸èƒ½ä½¿ç”¨æ·å¾‘'}`,
            { 
              answer: playerAnswer, 
              correct: isCorrect, 
              challengeType: 'train', 
              nextMoveToShortcut: isCorrect,
              location: currentPlayer.locationName,
              timestamp: new Date().toISOString()
            }
          );
          
          // æ·»åŠ ç©å®¶è¨˜éŒ„
          addPlayerRecord(
            currentPlayer.id, 
            currentPlayer.location, 
            currentPlayer.locationName, 
            'ç«è»ŠæŒ‘æˆ°', 
            `æŒ‘æˆ°-${isCorrect ? 'æˆåŠŸ' : 'å¤±æ•—'}`
          );
        }
        
      } else {
        // ä¸€èˆ¬æŒ‘æˆ°è¨˜éŒ„
        const currentPlayer = players.find(p => p.isCurrentPlayer);
        if (currentPlayer) {
          recordGameAction(
            currentPlayer.id,
            currentPlayer.name,
            'challenge',
            `æŒ‘æˆ°${isCorrect ? 'æˆåŠŸ' : 'å¤±æ•—'}: ${challengeQuestion}`,
            { 
              answer: playerAnswer, 
              correct: isCorrect, 
              challengeType: 'general',
              location: currentPlayer.locationName,
              timestamp: new Date().toISOString()
            }
          );
          
          // æ·»åŠ ç©å®¶è¨˜éŒ„
          addPlayerRecord(
            currentPlayer.id, 
            currentPlayer.location, 
            currentPlayer.locationName, 
            'æƒ…å¢ƒæŒ‘æˆ°', 
            `${isCorrect ? 'æˆåŠŸ' : 'å¤±æ•—'} - ${challengeQuestion.substring(0, 20)}...`
          );
        }
      }
    }
  };

  // STT ç›¸é—œå‡½æ•¸
  const startRecording = useCallback(async () => {
    console.log('startRecording è¢«èª¿ç”¨ï¼ŒcurrentWordCard:', currentWordCard);
    console.log('selectedCouponChallengeType:', selectedCouponChallengeType);
    console.log('scenarioSessionId:', scenarioSessionId);
    console.log('selectedChallengeType:', selectedChallengeType);
    console.log('challengeSessionId:', challengeSessionId);
    console.log('showChallengePanel:', showChallengePanel);
    console.log('currentChallenge:', currentChallenge);
    
    // æª¢æŸ¥æ˜¯å¦åœ¨æƒ…å¢ƒå°è©±æ¨¡å¼
    const isScenarioMode = selectedCouponChallengeType === 'scenario' && scenarioSessionId;
    // æª¢æŸ¥æ˜¯å¦åœ¨æŒ‘æˆ°å°è©±æ¨¡å¼
    const isChallengeMode = selectedChallengeType && challengeSessionId;
    // é¡å¤–æª¢æŸ¥ï¼šå¦‚æœåœ¨æŒ‘æˆ°é¢æ¿ä¸”é¡¯ç¤ºå°è©±
    const isInChallengeDialog = showChallengePanel && challengeSessionId;
    
    console.log('isScenarioMode:', isScenarioMode, 'isChallengeMode:', isChallengeMode, 'isInChallengeDialog:', isInChallengeDialog);
    
    if (!isScenarioMode && !currentWordCard && !isChallengeMode && !isInChallengeDialog) {
      console.error('é–‹å§‹éŒ„éŸ³æ™‚æ²’æœ‰ç•¶å‰å–®å­—å¡ç‰‡ä¸”ä¸åœ¨æƒ…å¢ƒå°è©±æ¨¡å¼æˆ–æŒ‘æˆ°å°è©±æ¨¡å¼');
      console.error('è©³ç´°ç‹€æ…‹:', {
        isScenarioMode,
        currentWordCard: !!currentWordCard,
        isChallengeMode,
        isInChallengeDialog,
        selectedChallengeType,
        challengeSessionId,
        showChallengePanel
      });
      return;
    }
    
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const recorder = new MediaRecorder(stream);
      
      recorder.ondataavailable = (event) => {
        console.log('éŒ„éŸ³è³‡æ–™å¯ç”¨:', event.data.size, 'bytes');
        console.log('éŒ„éŸ³æ™‚ currentWordCard:', currentWordCard);
        if (event.data.size > 0) {
          processVoiceInput(event.data);
        }
      };
      
      recorder.onstop = () => {
        console.log('éŒ„éŸ³åœæ­¢');
        stream.getTracks().forEach(track => track.stop());
      };
      
      recorder.start();
      setMediaRecorder(recorder);
      setIsRecording(true);
      console.log('é–‹å§‹éŒ„éŸ³');
    } catch (error) {
      console.error('ç„¡æ³•é–‹å§‹éŒ„éŸ³:', error);
      alert('ç„¡æ³•è¨ªå•éº¥å…‹é¢¨ï¼Œè«‹æª¢æŸ¥æ¬Šé™è¨­å®š');
    }
  }, [currentWordCard, selectedCouponChallengeType, scenarioSessionId]);

  const stopRecording = useCallback(() => {
    if (mediaRecorder && isRecording) {
      console.log('åœæ­¢éŒ„éŸ³');
      mediaRecorder.stop();
      setIsRecording(false);
      setMediaRecorder(null);
    }
  }, [mediaRecorder, isRecording]);

  const processVoiceInput = useCallback(async (audioBlob: Blob) => {
    console.log('processVoiceInput è¢«èª¿ç”¨');
    
    setIsProcessing(true);
    
    try {
      // æª¢æŸ¥æ˜¯å¦åœ¨æƒ…å¢ƒæŒ‘æˆ°æ¨¡å¼
      if (selectedCouponChallengeType === 'scenario' && scenarioSessionId) {
        console.log('æƒ…å¢ƒå°è©±æ¨¡å¼ï¼šè™•ç†èªéŸ³è¼¸å…¥');
        
        // ä½¿ç”¨æƒ…å¢ƒå°è©±çš„èªéŸ³æœå‹™ï¼ˆåƒè€ƒ Home.tsx çš„é‚è¼¯ï¼‰
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.webm');
        formData.append('session_id', scenarioSessionId);
        formData.append('user_id', localStorage.getItem('userId') || 'default_user');
        formData.append('chat_choose_id', 'default_chat_choose'); // ä½¿ç”¨é è¨­å€¼
        formData.append('title', 'å°èªèªéŸ³å°è©±');
        
        console.log('ç™¼é€æƒ…å¢ƒå°è©± STT è«‹æ±‚åˆ°:', 'http://localhost:5050/process_audio');
        
        const response = await fetch('http://localhost:5050/process_audio', {
          method: 'POST',
          body: formData,
        });
        
        console.log('æƒ…å¢ƒå°è©± STT éŸ¿æ‡‰ç‹€æ…‹:', response.status, response.statusText);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('æƒ…å¢ƒå°è©± STT æœå‹™éŒ¯èª¤éŸ¿æ‡‰:', errorText);
          throw new Error(`æƒ…å¢ƒå°è©±èªéŸ³æœå‹™éŒ¯èª¤: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        console.log('æƒ…å¢ƒå°è©± STT éŸ¿æ‡‰çµæœ:', result);
        
        if (result.success) {
          // ä¸€æ¬¡æ€§æ·»åŠ ç”¨æˆ¶èªéŸ³è¾¨è­˜çµæœå’ŒAIå›æ‡‰
          setScenarioMessages(prev => {
            const newMessages = [...prev];
            
            // æ·»åŠ ç”¨æˆ¶çš„èªéŸ³è¾¨è­˜çµæœ
            if (result.transcription) {
              console.log('ç”¨æˆ¶èªéŸ³è¾¨è­˜çµæœ:', result.transcription);
              newMessages.push({ 
                type: 'outgoing' as const, 
                sender: 'ä½ ', 
                content: result.transcription 
              });
            }
            
            // æ·»åŠ AIå›æ‡‰
            if (result.ai_response) {
              console.log('AI å›æ‡‰:', result.ai_response);
              newMessages.push({ 
                type: 'incoming' as const, 
                sender: 'å°ç†Š', 
                content: result.ai_response 
              });
            }
            
            // åœ¨æ›´æ–°æ¶ˆæ¯å¾Œè¨ˆç®—å°è©±æ¬¡æ•¸
            const conversationCount = newMessages.length;
            console.log('èªéŸ³è¼¸å…¥å¾Œçš„æ¶ˆæ¯æ•¸é‡:', conversationCount);
            
            return newMessages;
          });
          
          // æ’­æ”¾ TTS éŸ³é »
          if (result.ai_response && result.audio_url) {
            console.log('æ’­æ”¾ TTS éŸ³é »:', result.audio_url);
            const audio = new Audio(result.audio_url);
            audio.play().catch(error => {
              console.error('TTS éŸ³é »æ’­æ”¾å¤±æ•—:', error);
            });
          }
          
          // ä½¿ç”¨ç¾æœ‰çš„ scenario API ä¿å­˜å°è©±è¨˜éŒ„
          if (result.transcription) {
            try {
              const turnResult = await fetch('http://127.0.0.1:2083/api/v1/scenario/turn_text', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  session_id: scenarioSessionId,
                  text: result.transcription
                })
              });
              
              const turnResponse = await turnResult.json();
              console.log('æƒ…å¢ƒå°è©±å›åˆçµæœ:', turnResponse);
              console.log('å›åˆè©³ç´°è³‡è¨Š:', { 
                finished: turnResponse?.body?.finished, 
                turn: turnResponse?.body?.turn, 
                score: turnResponse?.body?.score 
              });
              
              // æ³¨æ„ï¼šé€™è£¡æˆ‘å€‘å·²ç¶“åœ¨ setScenarioMessages ä¸­æ­£ç¢ºè¨ˆç®—äº†å°è©±æ¬¡æ•¸
              // æˆ‘å€‘éœ€è¦ç­‰å¾…ç‹€æ…‹æ›´æ–°å¾Œå†æª¢æŸ¥æˆåŠŸæ¢ä»¶
              // ä½¿ç”¨ setTimeout ç¢ºä¿ç‹€æ…‹å·²æ›´æ–°
              setTimeout(() => {
                setScenarioMessages(currentMessages => {
                  const conversationCount = currentMessages.length;
                  const isSuccess = conversationCount >= 3;
                  
                  console.log('æƒ…å¢ƒæŒ‘æˆ°çµæœåˆ¤æ–· (èªéŸ³è¼¸å…¥):', { 
                    conversationCount, 
                    turn: turnResponse.body.turn || 0, 
                    score: turnResponse.body.score || 0, 
                    isSuccess,
                    messages: currentMessages.length
                  });
                  
                  if (isSuccess) {
                    setCouponChallengeResult('success');
                    console.log('ğŸ‰ æƒ…å¢ƒæŒ‘æˆ°æˆåŠŸï¼');
                    
                    // æª¢æŸ¥æ˜¯å¦åœ¨17ä½ç½®æŒ‘æˆ°æˆåŠŸ
                    const currentPlayer = players.find(p => p.isCurrentPlayer);
                    if (currentPlayer && currentPlayer.locationName === '17') {
                      console.log('17æŒ‘æˆ°æˆåŠŸï¼è¨­ç½®è©²ç©å®¶å¯ä»¥å¾€D5ç§»å‹•');
                      setO17ChallengeSuccessPlayers(prev => ({
                        ...prev,
                        [currentPlayer.id]: true
                      }));
                    }
                    
                    // è¨˜éŒ„éŠæˆ²å‹•ä½œï¼ˆåªæœ‰æˆåŠŸæ™‚æ‰è¨˜éŒ„ï¼‰
                    if (currentPlayer) {
                      recordGameAction(
                        currentPlayer.id,
                        currentPlayer.name,
                        'challenge',
                        `${currentPlayer.name} æƒ…å¢ƒæŒ‘æˆ°: æˆåŠŸ`,
                        { 
                          challengeType: 'scenario',
                          conversationCount: conversationCount,
                          location: currentPlayer.locationName,
                          timestamp: new Date().toISOString(),
                          correct: true
                        }
                      );
                    }
                  }
                  // å¦‚æœå°è©±æ¬¡æ•¸é‚„æ²’é”åˆ°3æ¬¡ï¼Œä¸è¨­ç½®å¤±æ•—çµæœï¼Œè®“ç©å®¶ç¹¼çºŒå°è©±
                  
                  return currentMessages; // ä¸ä¿®æ”¹æ¶ˆæ¯ï¼Œåªæ˜¯æª¢æŸ¥æˆåŠŸæ¢ä»¶
                });
              }, 100); // ç­‰å¾… 100ms ç¢ºä¿ç‹€æ…‹å·²æ›´æ–°
            } catch (error) {
              console.error('ä¿å­˜å°è©±è¨˜éŒ„å¤±æ•—:', error);
            }
          }
        } else {
          console.error('æƒ…å¢ƒå°è©±èªéŸ³è¾¨è­˜å¤±æ•—ï¼ŒéŸ¿æ‡‰:', result);
        }
        
      } else if (currentWordCard) {
        // å–®å­—æŒ‘æˆ°æ¨¡å¼ï¼ˆä¿æŒåŸæœ‰é‚è¼¯ï¼‰
        console.log('å–®å­—æŒ‘æˆ°æ¨¡å¼ï¼šè™•ç†èªéŸ³è¼¸å…¥');
        console.log('ç›®æ¨™å–®å­— (ä¸­æ–‡ç¿»è­¯):', currentWordCard.ch);
        console.log('ç›®æ¨™å–®å­— (å°èªæ¼¢å­—):', currentWordCard.han);
        
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.webm');
        formData.append('session_id', 'word_card_challenge');
        formData.append('user_id', localStorage.getItem('userId') || 'default_user');
        formData.append('chat_choose_id', 'word_card_challenge');
        formData.append('title', 'å°èªå–®å­—æŒ‘æˆ°');
        formData.append('skip_llm', 'true');
        formData.append('skip_tts', 'true');
        formData.append('skip_db', 'true');
        
        const response = await fetch('http://localhost:5050/process_audio', {
          method: 'POST',
          body: formData,
        });
        
        const result = await response.json();
        
        if (result.success && result.transcription) {
          const transcription = result.transcription.trim();
          setWordCardSTTResult(transcription);
          
          const isCorrect = transcription === currentWordCard.ch || transcription === currentWordCard.han;
          setWordCardChallengeResult(isCorrect ? 'success' : 'failure');
          
          console.log(`å–®å­—æŒ‘æˆ°çµæœ: "${transcription}" vs ä¸­æ–‡ç¿»è­¯"${currentWordCard.ch}" æˆ– å°èªæ¼¢å­—"${currentWordCard.han}" = ${isCorrect ? 'æˆåŠŸ' : 'å¤±æ•—'}`);
          
          // è¨˜éŒ„å–®å­—æŒ‘æˆ°çµæœåˆ°è³‡æ–™åº«
          const currentPlayer = players.find(p => p.isCurrentPlayer);
          if (currentPlayer) {
            recordGameAction(
              currentPlayer.id,
              currentPlayer.name,
              'challenge',
              `å–®å­—æŒ‘æˆ°${isCorrect ? 'æˆåŠŸ' : 'å¤±æ•—'}: ${currentWordCard.han} (${currentWordCard.ch})`,
              {
                challengeType: 'vocabulary',
                word: currentWordCard.han,
                meaning: currentWordCard.ch,
                answer: transcription,
                correct: isCorrect,
                location: currentPlayer.locationName,
                timestamp: new Date().toISOString()
              }
            );
          }
        }
      } else if (selectedChallengeType && challengeSessionId) {
        // æŒ‘æˆ°å°è©±æ¨¡å¼ - ç›´æ¥ä½¿ç”¨æƒ…å¢ƒæŒ‘æˆ°çš„èªéŸ³è™•ç†é‚è¼¯
        console.log('æŒ‘æˆ°å°è©±æ¨¡å¼ï¼šè™•ç†èªéŸ³è¼¸å…¥');
        
        const formData = new FormData();
        formData.append('audio', audioBlob, 'recording.webm');
        formData.append('session_id', challengeSessionId);
        formData.append('user_id', localStorage.getItem('userId') || 'default_user');
        formData.append('chat_choose_id', 'challenge_scenario');
        formData.append('title', 'å°èªæŒ‘æˆ°å°è©±');
        
        console.log('ç™¼é€æŒ‘æˆ°å°è©± STT è«‹æ±‚åˆ°:', 'http://localhost:5050/process_audio');
        
        const response = await fetch('http://localhost:5050/process_audio', {
          method: 'POST',
          body: formData,
        });
        
        console.log('æŒ‘æˆ°å°è©± STT éŸ¿æ‡‰ç‹€æ…‹:', response.status, response.statusText);
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('æŒ‘æˆ°å°è©± STT æœå‹™éŒ¯èª¤éŸ¿æ‡‰:', errorText);
          throw new Error(`æŒ‘æˆ°å°è©±èªéŸ³æœå‹™éŒ¯èª¤: ${response.status} - ${errorText}`);
        }
        
        const result = await response.json();
        console.log('æŒ‘æˆ°å°è©± STT éŸ¿æ‡‰çµæœ:', result);
        
        if (result.success) {
          // é¡¯ç¤ºå°èªè¾¨è­˜çµæœï¼ˆç”¨æˆ¶çš„èªéŸ³å…§å®¹ï¼‰
          if (result.transcription) {
            console.log('ç”¨æˆ¶èªéŸ³è¾¨è­˜çµæœ:', result.transcription);
            setChallengeMessages(prev => [...prev, { 
              type: 'outgoing' as const, 
              sender: 'ä½ ', 
              content: result.transcription 
            }]);
          }
          
          // é¡¯ç¤ºå°èªAIå›æ‡‰
          if (result.ai_response) {
            console.log('AI å›æ‡‰:', result.ai_response);
            setChallengeMessages(prev => [...prev, { 
              type: 'incoming' as const, 
              sender: 'å°ç†Š', 
              content: result.ai_response 
            }]);
            
            // æ’­æ”¾ TTS éŸ³é »
            if (result.audio_url) {
              console.log('æ’­æ”¾ TTS éŸ³é »:', result.audio_url);
              const audio = new Audio(result.audio_url);
              audio.play().catch(error => {
                console.error('TTS éŸ³é »æ’­æ”¾å¤±æ•—:', error);
              });
            }
          }
          
          // ä½¿ç”¨ç¾æœ‰çš„ scenario API ä¿å­˜å°è©±è¨˜éŒ„
          if (result.transcription) {
            try {
              const turnResult = await fetch('http://127.0.0.1:2083/api/v1/scenario/turn_text', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  session_id: challengeSessionId,
                  text: result.transcription
                })
              });
              
              const turnResponse = await turnResult.json();
              console.log('æŒ‘æˆ°å°è©±å›åˆçµæœ:', turnResponse);
              
              // å‰ç«¯åˆ¤æ–·æˆåŠŸæ¢ä»¶ï¼šå°è©±3æ¬¡å°±ç®—æˆåŠŸ
              setTimeout(() => {
                setChallengeMessages(currentMessages => {
                  const conversationCount = currentMessages.length;
                  const isSuccess = conversationCount >= 3;
                  
                  console.log('æŒ‘æˆ°å°è©±çµæœåˆ¤æ–·:', { 
                    conversationCount, 
                    isSuccess,
                    messages: currentMessages.length
                  });
                  
                  if (isSuccess) {
                    setChallengeResult('success');
                    console.log('ğŸ‰ æŒ‘æˆ°å°è©±æˆåŠŸï¼');
                    
                    // æª¢æŸ¥æ˜¯å¦åœ¨17ä½ç½®æŒ‘æˆ°æˆåŠŸ
                    const currentPlayer = players.find(p => p.isCurrentPlayer);
                    if (currentPlayer && currentPlayer.locationName === '17') {
                      console.log('17æŒ‘æˆ°æˆåŠŸï¼è¨­ç½®è©²ç©å®¶å¯ä»¥å¾€D5ç§»å‹•');
                      setO17ChallengeSuccessPlayers(prev => ({
                        ...prev,
                        [currentPlayer.id]: true
                      }));
                    }
                  }
                  // å¦‚æœå°è©±æ¬¡æ•¸é‚„æ²’é”åˆ°3æ¬¡ï¼Œè®“ç©å®¶ç¹¼çºŒå°è©±
                  
                  return currentMessages;
                });
              }, 100);
              
            } catch (error) {
              console.error('ä¿å­˜æŒ‘æˆ°å°è©±è¨˜éŒ„å¤±æ•—:', error);
            }
          }
        } else {
          console.error('æŒ‘æˆ°å°è©±èªéŸ³è¾¨è­˜å¤±æ•—ï¼ŒéŸ¿æ‡‰:', result);
        }
      } else {
        console.error('æ²’æœ‰ç•¶å‰å–®å­—å¡ç‰‡æˆ–æƒ…å¢ƒæœƒè©±');
      }
    } catch (error) {
      console.error('èªéŸ³è™•ç†éŒ¯èª¤:', error);
    } finally {
      setIsProcessing(false);
    }
  }, [currentWordCard, selectedCouponChallengeType, scenarioSessionId, scenarioMessages]);

  // é‡ç½®æŒ‘æˆ°ç‹€æ…‹
  const resetChallenge = () => {
    const wasTrainChallenge = currentChallenge?.type === 'train' || currentChallenge?.type === 'transport';
    const currentPlayer = players.find(p => p.isCurrentPlayer);
    
    // è¨˜éŒ„æŒ‘æˆ°çµæœï¼ˆå¦‚æœæœ‰çµæœçš„è©±ï¼‰
    if (currentPlayer) {
      if (challengeResult) {
        const challengeTypeName = wasTrainChallenge ? 'ç«è»ŠæŒ‘æˆ°' : 
                                 currentChallenge?.type === 'vocabulary' ? 'å–®å­—æŒ‘æˆ°' : 
                                 currentChallenge?.type === 'story' ? 'æƒ…å¢ƒæŒ‘æˆ°' : 'æŒ‘æˆ°';
        
        recordGameAction(
          currentPlayer.id,
          currentPlayer.name,
          'challenge',
          `${challengeTypeName}${challengeResult === 'success' ? 'æˆåŠŸ' : 'å¤±æ•—'}`,
          {
            challengeType: wasTrainChallenge ? 'train' : currentChallenge?.type || 'general',
            correct: challengeResult === 'success',
            location: currentPlayer.locationName,
            timestamp: new Date().toISOString()
          }
        );
      } else if (couponChallengeResult) {
        // è¨˜éŒ„å„ªæƒ åˆ¸æŒ‘æˆ°çµæœ
        const challengeTypeName = currentChallenge?.type === 'transport' ? 'ç«è»ŠæŒ‘æˆ°' : 'æƒ…å¢ƒæŒ‘æˆ°';
        
        recordGameAction(
          currentPlayer.id,
          currentPlayer.name,
          'challenge',
          `${challengeTypeName}${couponChallengeResult === 'success' ? 'æˆåŠŸ' : 'å¤±æ•—'}`,
          {
            challengeType: 'coupon',
            correct: couponChallengeResult === 'success',
            location: currentPlayer.locationName,
            timestamp: new Date().toISOString()
          }
        );
      }
    }
    
    setSelectedCouponChallengeType(null);
    setChallengeQuestion('');
    setPlayerAnswer('');
    setChallengeResult(null);
    setCouponChallengeResult(null); // é‡ç½®æƒ…å¢ƒæŒ‘æˆ°çµæœ
    setShowChallengePanel(false);
    setCurrentChallenge(null);
    
    // é‡ç½®æƒ…å¢ƒæŒ‘æˆ°ç›¸é—œç‹€æ…‹
    setScenarioSessionId(null);
    setScenarioMessages([]);
    setScenarioIsProcessing(false);
    
    // æ³¨æ„ï¼šä¸é‡ç½® playerShortcutPrivilegesï¼Œå› ç‚ºé€™äº›æ˜¯æŒ‘æˆ°çµæœï¼ŒæŒ‰ç©å®¶è¨˜éŒ„
    
    // å¦‚æœæ˜¯ç«è»ŠæŒ‘æˆ°ï¼Œå®Œæˆå¾Œè‡ªå‹•åˆ‡æ›åˆ°ä¸‹ä¸€ä½ç©å®¶
    if (wasTrainChallenge) {
      switchToNextPlayer();
    } else if (currentPlayer && currentPlayer.locationName === '17' && challengeResult === 'success') {
      // 17 æŒ‘æˆ°æˆåŠŸå¾Œç§»å‹•åˆ° D5
      console.log('17 æŒ‘æˆ°æˆåŠŸï¼Œç§»å‹•åˆ° D5');
      
      // æ›´æ–°ç©å®¶ä½ç½®åˆ° D5
      const updatedPlayers = players.map(player => {
        if (player.id === currentPlayer.id) {
          return {
            ...player,
            location: 'D5', // ä½¿ç”¨D5ä½œç‚ºä½ç½®
            locationName: 'D5'
          };
        }
        return player;
      });
      
      setPlayers(updatedPlayers);
      
      // è¨˜éŒ„ç§»å‹•
      recordGameAction(
        currentPlayer.id,
        currentPlayer.name,
        'move',
        `${currentPlayer.name} 17æŒ‘æˆ°æˆåŠŸï¼Œç§»å‹•åˆ° D5`,
        { 
          from: '17', 
          to: 'D5', 
          reason: 'challenge_success',
          challengeType: 'culture'
        }
      );
      
      // æ›´æ–°ç©å®¶ç‹€æ…‹
      updatePlayerStatus(currentPlayer.id, {
        locationName: 'D5',
        record: `17æŒ‘æˆ°æˆåŠŸï¼Œç§»å‹•åˆ°D5`
      });
      
      // æŒ‘æˆ°å®Œæˆå¾Œåˆ‡æ›åˆ°ä¸‹ä¸€ä½ç©å®¶
      switchToNextPlayer();
    } else {
      // å…¶ä»–æŒ‘æˆ°å®Œæˆå¾Œç›´æ¥åˆ‡æ›ç©å®¶
      switchToNextPlayer();
    }
  };

  // è™•ç†å„ªæƒ åˆ¸æŒ‘æˆ°ä¸»é¡Œé¸æ“‡ - æ”¹ç‚ºæƒ…å¢ƒå°è©±
  const handleCouponChallengeTypeSelect = async () => {
    setSelectedCouponChallengeType('scenario');
    setCouponChallengeResult(null);
    setScenarioMessages([]);
    setScenarioPlayerInput('');
    setScenarioSessionId(null);
    
    // è‡ªå‹•é–‹å§‹æƒ…å¢ƒå°è©±
    await handleStartScenarioChallenge();
  };

  // é–‹å§‹æƒ…å¢ƒå°è©±æŒ‘æˆ°
  const handleStartScenarioChallenge = async () => {
    try {
      // æ ¹æ“šç•¶å‰éŠæˆ²ä¸»é¡Œé¸æ“‡å°æ‡‰çš„æƒ…å¢ƒä¸»é¡Œ
      if (scenarioTopics.length === 0) {
        console.error('æ²’æœ‰å¯ç”¨çš„æƒ…å¢ƒä¸»é¡Œ');
        return;
      }
      
      // æ ¹æ“šéŠæˆ²ä¸»é¡Œéæ¿¾æƒ…å¢ƒä¸»é¡Œ
      let filteredTopics = scenarioTopics;
      if (gameTheme === 'traffic') {
        // äº¤é€šå·¥å…·ä¸»é¡Œï¼šé¸æ“‡ã€Œäº¤é€šå·¥å…·ã€æƒ…å¢ƒ
        filteredTopics = scenarioTopics.filter(topic => 
          topic.name === 'äº¤é€šå·¥å…·'
        );
      } else if (gameTheme === 'occupation') {
        // è·æ¥­ä¸»é¡Œï¼šé¸æ“‡ã€Œè·æ¥­èˆ‡ç¤¾æœƒè§’è‰²ã€æƒ…å¢ƒ
        filteredTopics = scenarioTopics.filter(topic => 
          topic.name === 'è·æ¥­èˆ‡ç¤¾æœƒè§’è‰²'
        );
      }
      
      // å¦‚æœæ²’æœ‰æ‰¾åˆ°å°æ‡‰ä¸»é¡Œï¼Œå‰‡ä½¿ç”¨éš¨æ©Ÿä¸»é¡Œ
      if (filteredTopics.length === 0) {
        filteredTopics = scenarioTopics;
      }
      
      const selectedTopic = filteredTopics[Math.floor(Math.random() * filteredTopics.length)];
      console.log('é¸æ“‡çš„æƒ…å¢ƒä¸»é¡Œ:', selectedTopic.name, 'éŠæˆ²ä¸»é¡Œ:', gameTheme);
      
      const userId = localStorage.getItem('userId') || 'default_user';
      
      // é–‹å§‹æƒ…å¢ƒå°è©±
      const response = await fetch('http://127.0.0.1:2083/api/v1/scenario/start', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          chatChooseId: selectedTopic._id,
          userId: userId
        })
      });
      
      const result = await response.json();
      
      if (result.code === 200 && result.body) {
        setScenarioSessionId(result.body.session_id);
        setScenarioMessages([
          { type: 'incoming', sender: 'å°ç†Š', content: result.body.npc_text }
        ]);
      } else {
        console.error('æƒ…å¢ƒå°è©±å•Ÿå‹•å¤±æ•—:', result.message);
      }
    } catch (error) {
      console.error('æƒ…å¢ƒå°è©±å•Ÿå‹•éŒ¯èª¤:', error);
    }
  };

  // è™•ç†æƒ…å¢ƒå°è©±æäº¤ (æœªä½¿ç”¨)
  const _handleScenarioSubmit = async () => {
    if (!scenarioSessionId || !scenarioPlayerInput.trim() || scenarioIsProcessing) {
      return;
    }
    
    const userInput = scenarioPlayerInput.trim();
    setScenarioPlayerInput('');
    setScenarioIsProcessing(true);
    
    // æ·»åŠ ç”¨æˆ¶è¨Šæ¯
    setScenarioMessages(prev => {
      const newMessages = [...prev, { type: 'outgoing' as const, sender: 'ä½ ', content: userInput }];
      console.log('æ·»åŠ ç”¨æˆ¶æ¶ˆæ¯å¾Œçš„æ¶ˆæ¯æ•¸é‡:', newMessages.length);
      console.log('ç”¨æˆ¶è¼¸å…¥:', userInput);
      return newMessages;
    });
    
    try {
      // ç™¼é€æƒ…å¢ƒå°è©±å›åˆ
      const response = await fetch('http://127.0.0.1:2083/api/v1/scenario/turn_text', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          session_id: scenarioSessionId,
          text: userInput
        })
      });
      
      const result = await response.json();
      
      if (result.code === 200 && result.body) {
        // æ·»åŠ  NPC å›æ‡‰
        setScenarioMessages(prev => {
          const newMessages = [...prev, { 
            type: 'incoming' as const, 
            sender: 'å°ç†Š', 
            content: result.body.npc_text 
          }];
          
          // åœ¨æ›´æ–°æ¶ˆæ¯å¾Œè¨ˆç®—å°è©±æ¬¡æ•¸
          const conversationCount = newMessages.length;
          
          // æˆåŠŸæ¢ä»¶ï¼šå°è©±æ¬¡æ•¸é”åˆ°3æ¬¡ï¼ˆç°¡å–®åˆ¤æ–·ï¼‰
          const isSuccess = conversationCount >= 3;
          console.log('æƒ…å¢ƒæŒ‘æˆ°çµæœåˆ¤æ–·:', { 
            conversationCount, 
            turn: result.body.turn || 0, 
            score: result.body.score || 0, 
            isSuccess,
            messages: newMessages.length,
            previousLength: prev.length,
            newMessageAdded: result.body.npc_text
          });
          
          // è©³ç´°èª¿è©¦ï¼šé¡¯ç¤ºæ‰€æœ‰æ¶ˆæ¯å…§å®¹
          console.log('æ‰€æœ‰å°è©±æ¶ˆæ¯:', newMessages.map((msg, index) => ({
            index,
            type: msg.type,
            sender: msg.sender,
            content: msg.content
          })));
          
          if (isSuccess) {
            setCouponChallengeResult('success');
            console.log('ğŸ‰ æƒ…å¢ƒæŒ‘æˆ°æˆåŠŸï¼');
          }
          
          return newMessages;
        });
      } else {
        console.error('æƒ…å¢ƒå°è©±å›åˆå¤±æ•—:', result.message);
        setScenarioMessages(prev => [...prev, { 
          type: 'incoming', 
          sender: 'ç³»çµ±', 
          content: 'å°è©±è™•ç†å¤±æ•—ï¼Œè«‹é‡è©¦' 
        }]);
      }
    } catch (error) {
      console.error('æƒ…å¢ƒå°è©±æäº¤éŒ¯èª¤:', error);
      setScenarioMessages(prev => [...prev, { 
        type: 'incoming', 
        sender: 'ç³»çµ±', 
        content: 'ç¶²è·¯éŒ¯èª¤ï¼Œè«‹é‡è©¦' 
      }]);
    } finally {
      setScenarioIsProcessing(false);
    }
  };

  // è™•ç†å„ªæƒ åˆ¸æŒ‘æˆ°ç­”æ¡ˆæäº¤ (æœªä½¿ç”¨ - å·²å»¢æ£„)

  // é‡ç½®å„ªæƒ åˆ¸æŒ‘æˆ°ç‹€æ…‹
  const resetCouponChallenge = () => {
    const currentPlayer = players.find(p => p.isCurrentPlayer);
    
    // è¨˜éŒ„å„ªæƒ åˆ¸æŒ‘æˆ°çµæœï¼ˆå¦‚æœæœ‰çµæœçš„è©±ï¼‰
    if (currentPlayer && couponChallengeResult) {
      const challengeTypeName = couponType === 'gas_station' ? 'åŠ æ²¹ç«™æŒ‘æˆ°' : 
                               couponType === 'road_construction' ? 'é“è·¯æ–½å·¥æŒ‘æˆ°' : 
                               couponType === 'property' ? 'æˆ¿åœ°ç”¢æŒ‘æˆ°' : 'å„ªæƒ åˆ¸æŒ‘æˆ°';
      
      recordGameAction(
        currentPlayer.id,
        currentPlayer.name,
        'challenge',
        `${challengeTypeName}${couponChallengeResult === 'success' ? 'æˆåŠŸ' : 'å¤±æ•—'}`,
        {
          challengeType: 'coupon',
          couponType: couponType,
          correct: couponChallengeResult === 'success',
          location: currentPlayer.locationName,
          timestamp: new Date().toISOString()
        }
      );
    }
    
    setSelectedCouponChallengeType(null);
    setCouponChallengeQuestion('');
    setCouponPlayerAnswer('');
    setCouponChallengeResult(null);
    setShowCouponChallengePanel(false);
    
    if (currentPlayer) {
      // åŠ æ²¹ç«™æŒ‘æˆ°å®Œæˆå¾Œæš«åœä¸€æ¬¡
      if (couponType === 'gas_station') {
        setPlayerSkipped(true);
        recordGameAction(
          currentPlayer.id,
          currentPlayer.name,
          'move',
          `${currentPlayer.name} å®ŒæˆåŠ æ²¹ç«™æŒ‘æˆ°ï¼Œæš«åœä¸€æ¬¡`,
          { location: currentPlayer.location, skipped: true, couponType }
        );
      }
      // é“è·¯æ–½å·¥æŒ‘æˆ°å®Œæˆå¾Œä¸éœ€è¦é¡å¤–è¨­ç½®æš«åœï¼ˆå·²åœ¨æŒ‘æˆ°çµæœä¸­è™•ç†ï¼‰
    }
    
    // å„ªæƒ åˆ¸æŒ‘æˆ°å®Œæˆå¾Œè‡ªå‹•åˆ‡æ›åˆ°ä¸‹ä¸€ä½ç©å®¶
    switchToNextPlayer();
  };

  // è™•ç†å°èªå¤§å–®æŒ‘ - ç›´æ¥ä½¿ç”¨éŠæˆ²ä¸»é¡Œ
  const handleWordChallenge = () => {
    setShowCouponPanel(false);
    setIsDrawingCard(true);
    
    // æŠ½å¡ç‰‡å‹•ç•«æ•ˆæœ
    setTimeout(async () => {
      try {
        // æ ¹æ“šéŠæˆ²ä¸»é¡Œç²å–å°æ‡‰çš„åˆ†é¡ ID
        const categoryId = gameTheme === 'traffic' 
          ? '6894ec12e4c25617b65cd248' // äº¤é€šå·¥å…·åˆ†é¡ ID
          : gameTheme === 'occupation' 
          ? '6894ec12e4c25617b65cd25c' // è·æ¥­èˆ‡ç¤¾æœƒè§’è‰²åˆ†é¡ ID
          : '6894ec12e4c25617b65cd248'; // é è¨­ä½¿ç”¨äº¤é€šå·¥å…·
        
        // ä½¿ç”¨åŸæœ¬çš„ API ç²å–å–®å­—å¡ç‰‡
        const response = await fetch(`http://127.0.0.1:2083/api/v1/vocab-cards/by-category/${categoryId}`);
        const result = await response.json();
        
        if (result.code === 200 && result.body && result.body.length > 0) {
          const randomIndex = Math.floor(Math.random() * result.body.length);
          const selectedCard = result.body[randomIndex];
          
          // ç²å–å°æ‡‰çš„åœ–ç‰‡
          try {
            const imageResponse = await fetch(`http://127.0.0.1:2083/api/v1/vocabulary-pictures/by-card/${selectedCard._id}`);
            const imageResult = await imageResponse.json();
            
            if (imageResult.code === 200 && imageResult.body) {
              selectedCard.image = imageResult.body.imageUrl;
              console.log('ç²å–åœ–ç‰‡æˆåŠŸ:', imageResult.body.imageUrl);
            } else {
              console.log('è©²å–®å­—å¡ç‰‡æ²’æœ‰å°æ‡‰çš„åœ–ç‰‡');
              selectedCard.image = null;
            }
          } catch (imageError) {
            console.error('ç²å–åœ–ç‰‡å¤±æ•—:', imageError);
            selectedCard.image = null;
          }
          
      console.log('è¨­ç½®æ–°çš„å–®å­—å¡ç‰‡:', selectedCard);
      setCurrentWordCard(selectedCard);
      setIsDrawingCard(false);
      setShowWordCard(true);
      
      // è¨˜éŒ„éŠæˆ²å‹•ä½œ
      const currentPlayer = players.find(p => p.isCurrentPlayer);
      if (currentPlayer) {
        recordGameAction(
          currentPlayer.id,
          currentPlayer.name,
          'challenge',
              `æŠ½å–å–®å­—å¡ç‰‡: ${selectedCard.han}`,
              { cardId: selectedCard._id, category: selectedCard.categoryId, theme: gameTheme }
            );
          }
        } else {
          console.error('æ²’æœ‰å¯ç”¨çš„å–®å­—å¡ç‰‡ï¼', result);
          setIsDrawingCard(false);
        }
      } catch (error) {
        console.error('ç²å–å–®å­—å¡ç‰‡å¤±æ•—:', error);
        setIsDrawingCard(false);
      }
    }, 2000); // 2ç§’æŠ½å¡ç‰‡å‹•ç•«
  };

  // é—œé–‰å–®å­—å¡ç‰‡
  const closeWordCard = () => {
    console.log('closeWordCard è¢«èª¿ç”¨');
    setShowWordCard(false);
    setCurrentWordCard(null);
    // é‡ç½® STT ç›¸é—œç‹€æ…‹
    setWordCardSTTResult('');
    setWordCardChallengeResult(null);
    setIsRecording(false);
    setIsProcessing(false);
    if (mediaRecorder) {
      mediaRecorder.stop();
      setMediaRecorder(null);
    }
    console.log('æº–å‚™èª¿ç”¨ switchToNextPlayer');
    switchToNextPlayer();
  };


  // å¦‚æœåœ°åœ–é‚„æ²’è¼‰å…¥ï¼Œé¡¯ç¤ºè¼‰å…¥ç•«é¢
  if (!isMapLoaded) {
    return (
      <div className="monopoly-container">
        <div className="loading-overlay">
          <div className="loading-content">
            <h2>è¼‰å…¥éŠæˆ²åœ°åœ–ä¸­...</h2>
            <div className="loading-spinner"></div>
            <p>æ­£åœ¨å¾ä¼ºæœå™¨ç²å–åœ°åœ–è³‡æ–™</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="monopoly-container">
      {/* ä¸»é¡Œé¸æ“‡è¦†è“‹å±¤ */}
      {showThemeSelection && (
        <div className="theme-selection-overlay">
          <div className="theme-selection-panel">
            <h2 className="theme-selection-title">é¸æ“‡éŠæˆ²ä¸»é¡Œ</h2>
            
            <div className="theme-options">
              {!themesLoaded ? (
                <div className="loading-themes">è¼‰å…¥ä¸»é¡Œä¸­...</div>
              ) : (
                availableThemes.map((theme) => (
              <button 
                    key={theme.id}
                    className={`theme-option-btn ${selectedTheme === theme.key ? 'selected' : ''}`}
                onClick={() => {
                      setSelectedTheme(theme.key);
                  audioManager.play(AudioType.THEME_SELECTION, 0.3);
                }}
              >
                    <img 
                      src={theme.key === 'traffic' ? "../src/assets/èª°æ˜¯äº¤é€šç‹.png" : "../src/assets/æ¤ç‰©ç™¾å¯¶è¢‹.png"} 
                      alt={theme.name} 
                    />
                    <span>{theme.key === 'traffic' ? 'èª°æ˜¯äº¤é€šç‹' : 'è·æ¶¯å¤§å†’éšª'}</span>
              </button>
                ))
              )}
            </div>
            
            <button 
              className="start-game-button"
              onClick={() => {
                if (selectedTheme) {
                  setGameTheme(selectedTheme);
                  setShowThemeSelection(false);
                  audioManager.play(AudioType.GAME_START, 0.5);
                }
              }}
              disabled={!selectedTheme}
            >
              é–‹å§‹éŠæˆ²
            </button>
          </div>
        </div>
      )}

      {/* è·¯å¾‘é¸æ“‡è¦†è“‹å±¤ */}
      {showPathSelection && pathOptions && (
        <div className="path-selection-overlay">
          <div className="path-selection-panel">
            <h2 className="path-selection-title">é¸æ“‡ç§»å‹•è·¯å¾‘</h2>
            <p className="path-selection-subtitle">17æŒ‘æˆ°æˆåŠŸï¼ä½ å¯ä»¥é¸æ“‡ç§»å‹•è·¯å¾‘ï¼š</p>
            
            <div className="path-options">
              <button 
                className="path-option-btn normal-path"
                onClick={() => handlePathSelection('normal')}
              >
                <div className="path-info">
                  <h3>æ­£å¸¸è·¯å¾‘</h3>
                  <p>ç§»å‹•åˆ°ï¼š{pathOptions.normal.position_info?.name || pathOptions.normal.new_position}</p>
                </div>
              </button>
              
              <button 
                className="path-option-btn d5-path"
                onClick={() => handlePathSelection('alternative')}
              >
                <div className="path-info">
                  <h3>D5è·¯å¾‘ ğŸ¯</h3>
                  <p>ç§»å‹•åˆ°ï¼š{pathOptions.alternative.new_position}</p>
                  <span className="special-path-badge">ç‰¹æ®Šè·¯å¾‘</span>
                </div>
              </button>
            </div>
          </div>
        </div>
      )}

      {/* é ‚éƒ¨å°èˆªæ¬„ */}
      <div className="top-bar">
        <button
          type="button"
          className="back-button"
          aria-label="è¿”å›"
          onClick={() => {
            audioManager.play(AudioType.THEME_SELECTION, 0.3);
            navigate("/Learn");
          }}
        >
          <img src={BackIcon} alt="è¿”å›" />
        </button>
        <div className="game-title">
          <span className="controller-icon">ğŸ®</span>
          <span className="title-text">
            éŠæˆ²ä¸­ - {currentPlayer ? `${currentPlayer.name} çš„å›åˆ` : 'ç­‰å¾…ä¸­'}
          </span>
        </div>
        <div className="room-info">
          {/* éŸ³æ•ˆæ§åˆ¶çµ„ä»¶ */}
          <AudioControls />
          <button 
            className="history-button"
            onClick={() => {
              audioManager.play(AudioType.THEME_SELECTION, 0.3);
              setShowGameHistory(true);
            }}
            title="æŸ¥çœ‹éŠæˆ²æ­·ç¨‹"
          >
            ğŸ“Š æ­·ç¨‹
          </button>
          <button 
            className="switch-player-button"
            onClick={() => {
              audioManager.play(AudioType.THEME_SELECTION, 0.3);
              switchToNextPlayer();
            }}
            title="æ‰‹å‹•åˆ‡æ›ç©å®¶"
          >
            ğŸ”„ æ›äºº
          </button>
          <span className="room-label">æˆ¿è™Ÿï¼š</span>
          <div className="room-number">1234</div>
        </div>
      </div>

      {/* ç©å®¶é ­åƒæ§½ä½ */}
      <div className="player-slots">
        {players.map((player) => (
          <div
            key={player.id}
            className={`player-slot ${player.isCurrentPlayer ? 'current-player' : ''}`}
          >
            <div className="player-avatar">
              {player.avatarImage ? (
                <img
                  src={player.avatarImage}
                  alt={player.name}
                  className="player-avatar-img"
                />
              ) : (
                <span>{player.avatar}</span>
              )}
            </div>
            <div className="player-label">ç©å®¶{player.id}</div>
          </div>
        ))}
      </div>

      {/* ç©å®¶è³‡è¨Šé¢æ¿å’ŒæŒ‘æˆ°é¢æ¿ */}
      {currentPlayer && (
        <div className="player-info-container">
          <div className="player-info-panel">
            <div className="player-header">
              <div className="player-avatar-large">
                {currentPlayer.avatarImage ? (
                  <img
                    src={currentPlayer.avatarImage}
                    alt={currentPlayer.name}
                    className="player-avatar-large-img"
                  />
                ) : (
                  <span>{currentPlayer.avatar}</span>
                )}
              </div>
              <div className="player-name">ç©å®¶{currentPlayer.id}:{currentPlayer.name}</div>
            </div>

            <div className="player-details">
              <div className="detail-row">
                <span className="detail-label">ç¶“éèµ·é»:</span>
                <div className="detail-value">
                  {playersPassedStart[currentPlayer.id] || 0} / 3
                </div>
              </div>
              <div className="detail-row">
                <span className="detail-label">ç‹€æ…‹:</span>
                <div className="detail-value">
                  {roadConstructionSkip[currentPlayer.id] ? 'æš«åœä¸€å›åˆ' : currentPlayer.status}
                </div>
              </div>
              <div className="detail-row">
                <span className="detail-label">ä½ç½®:</span>
                <div className="detail-value">{currentPlayer.locationName}</div>
              </div>
              <div className="detail-row">
                <span className="detail-label">æ·å¾‘:</span>
                <div className="detail-value">
                  {((currentPlayer.locationName >= '37' && currentPlayer.locationName <= '42') || 
                    (currentPlayer.locationName >= 'D0' && currentPlayer.locationName <= 'D5') || 
                    playerShortcutPrivileges[currentPlayer.id]?.nextMoveToShortcut) ? 'æ˜¯' : 'å¦'}
                </div>
              </div>
             
            </div>

            <div className="player-record">
              <span className="record-label">ç´€éŒ„:</span>
              <div className="record-list">
                {currentPlayer.records.slice(-3).reverse().map((record) => (
                  <div key={record.id} className="record-item">
                    <div className="record-content">
                      {record.details}
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div className="player-actions">
             
              <button 
                className="bankruptcy-button"
                onClick={handleBankruptcy}
              >
                ç ´ç”¢
              </button>
            </div>
          </div>

          {/* æŒ‘æˆ°å¡å´é‚Šé¢æ¿ */}
          {showChallengePanel && currentChallenge && (
            <div className="challenge-panel-side">
              <div className="challenge-header">
                <h2 className="challenge-title">
                  {currentChallenge?.type === 'train' || currentChallenge?.type === 'transport' ? 'ç«è»ŠæŒ‘æˆ°' : 
                   currentChallenge?.type === 'vocabulary' ? 'å–®å­—æŒ‘æˆ°' : 
                   currentChallenge?.type === 'story' ? 'æƒ…å¢ƒæŒ‘æˆ°' : 
                   currentChallenge?.type === 'action' ? 'å‹•ä½œæŒ‘æˆ°' : 
                   'æŒ‘æˆ°'}
                </h2>
             
              </div>
              <div className="challenge-content">
                <div className="challenge-question">
                  {!selectedCouponChallengeType ? (
                    <div className="question-bubble">
                      æ­£åœ¨æº–å‚™æŒ‘æˆ°...
                    </div>
                  ) : selectedCouponChallengeType === 'scenario' ? (
                    scenarioMessages.length > 0 ? (
                      <div className="scenario-messages-container">
                        {scenarioMessages.map((msg, index) => (
                          <div key={index} className={`scenario-message-bubble ${msg.type}`}>
                            <span className="message-content">{msg.content}</span>
                          </div>
                        ))}
                    </div>
                  ) : (
                      <div className="question-bubble">
                        æ­£åœ¨æº–å‚™æŒ‘æˆ°å°è©±...
                      </div>
                    )
                  ) : (
                    // å‚³çµ±å–®å­—æŒ‘æˆ°æ¨¡å¼
                    <div className="question-bubble">
                      {challengeQuestion}
                    </div>
                  )}
                  
                  {couponChallengeResult && (
                    <>
                      <div className={`response-bubble ${couponChallengeResult}`}>
                        {couponChallengeResult === 'success' ? 'ğŸ‰ æŒ‘æˆ°æˆåŠŸï¼' : 'âŒ æŒ‘æˆ°å¤±æ•—ï¼'}
                      </div>
                      {/* ç«è»ŠæŒ‘æˆ°ç‰¹æ®Šçå‹µä¿¡æ¯ */}
                      {currentChallenge?.type === 'train' || currentChallenge?.type === 'transport' ? (
                        <div className={`reward-bubble ${couponChallengeResult}`}>
                          {couponChallengeResult === 'success' ? 'ğŸš‚ ç«è»ŠæŒ‘æˆ°æˆåŠŸï¼ä¸‹æ¬¡æŒ‰éª°å­å°‡åœ¨æ·å¾‘è·¯ç·šç§»å‹•ï¼' : 'ğŸš‚ ç«è»ŠæŒ‘æˆ°å¤±æ•—ï¼æœ¬æ¬¡ä¸èƒ½ä½¿ç”¨æ·å¾‘'}
                        </div>
                      ) : (
                        <div className={`reward-bubble ${couponChallengeResult}`}>
                          {couponChallengeResult === 'success' ? 'ğŸ è«‹æŠ½å–ä¸€å¼µçå‹µå¡' : 'âš ï¸ è«‹æŠ½å–ä¸€å¼µæ‡²ç½°å¡'}
                        </div>
                      )}
                    </>
                  )}
                </div>
                
                <div className="challenge-buttons">
                  {!selectedCouponChallengeType ? (
                    <div className="challenge-actions">
                      <button 
                        className="challenge-complete-btn" 
                        onClick={handleChallengeTypeSelect}
                      >
                        é–‹å§‹æŒ‘æˆ°
                      </button>
                    </div>
                  ) : (
                    <div className="challenge-actions">
                      {couponChallengeResult && (
                        <button className="challenge-complete-btn" onClick={() => {
                          audioManager.play(AudioType.THEME_SELECTION, 0.3);
                          resetChallenge();
                        }}>
                          å®ŒæˆæŒ‘æˆ°
                        </button>
                      )}
                    </div>
                  )}
                </div>
                {selectedCouponChallengeType && !couponChallengeResult && (
                  selectedCouponChallengeType === 'scenario' ? (
                    // æŒ‘æˆ°å°è©±æ¨¡å¼ - ä½¿ç”¨æƒ…å¢ƒæŒ‘æˆ°çš„éº¥å…‹é¢¨æ¨£å¼
                  <div className="voice-input">
                      <div 
                        className="microphone-icon"
                        onClick={() => {
                          if (isRecording) {
                            stopRecording();
                          } else {
                            startRecording();
                          }
                        }}
                        style={{ 
                          cursor: 'pointer',
                          opacity: isProcessing ? 0.5 : 1,
                          backgroundColor: isRecording ? '#ff6b6b' : '#D2B48C'
                        }}
                      >
                        <img 
                          src="/src/assets/éº¥å…‹é¢¨.png" 
                          alt="éº¥å…‹é¢¨" 
                      />
                    </div>
                    </div>
                  ) : (
                    // å‚³çµ±å–®å­—æŒ‘æˆ°æ¨¡å¼
                    <div className="word-challenge-voice-mode">
                      {/* èªéŸ³è¼¸å…¥æç¤º */}
                      <div className="voice-input-hint">
                        <div className="question-bubble">
                          è«‹é»æ“Šéº¥å…‹é¢¨ï¼Œç”¨å°èªèªªå‡ºç­”æ¡ˆï¼
                        </div>
                      </div>
                      
                      {/* èªéŸ³è¾¨è­˜çµæœé¡¯ç¤º */}
                      {playerAnswer && (
                        <div className="voice-recognition-result">
                          <div className="question-bubble">
                            ä½ èªªçš„å°èªï¼š{playerAnswer}
                    </div>
                  </div>
                )}
                      
                      {/* éº¥å…‹é¢¨æŒ‰éˆ• */}
                      <div className="microphone-icon" onClick={isRecording ? stopRecording : startRecording}>
                        <img 
                          src="/src/assets/éº¥å…‹é¢¨.png" 
                          alt="éº¥å…‹é¢¨" 
                          style={{
                            backgroundColor: isRecording ? '#ff6b6b' : '#D2B48C',
                            width: '40px',
                            height: '40px',
                            borderRadius: '50%',
                            padding: '8px'
                          }}
                        />
              </div>
                      
                      {/* å®ŒæˆæŒ‰éˆ• - åªæœ‰èªéŸ³è¾¨è­˜çµæœå¾Œæ‰èƒ½é»æ“Š */}
                      {playerAnswer && (
                        <button 
                          className="challenge-complete-btn" 
                          onClick={handleAnswerSubmit}
                          style={{ marginTop: '10px' }}
                        >
                          ç¢ºèªç­”æ¡ˆ
                        </button>
                      )}
            </div>
                  )
                )}
              </div>
            </div>
          )}
        </div>
      )}

      {/* å„ªæƒ åˆ¸æŒ‘æˆ°é¢æ¿ */}
      {showCouponChallengePanel && (
        <div className="challenge-panel-side">
          <div className="challenge-header">
            <h2 className="challenge-title">æƒ…å¢ƒæŒ‘æˆ°</h2>
          </div>
          <div className="challenge-content">
            <div className="challenge-question">
              {!selectedCouponChallengeType ? (
                <div className="question-bubble">
                  æ­£åœ¨æº–å‚™æŒ‘æˆ°...
                </div>
              ) : selectedCouponChallengeType === 'scenario' ? (
                scenarioMessages.length > 0 ? (
                  <div className="scenario-messages-container">
                    {scenarioMessages.map((msg, index) => (
                      <div key={index} className={`scenario-message-bubble ${msg.type}`}>
                        <span className="message-content">{msg.content}</span>
                      </div>
                    ))}
                </div>
                ) : (
                  <div className="question-bubble">
                    æ­£åœ¨æº–å‚™æƒ…å¢ƒå°è©±...
                  </div>
                )
              ) : (
                <div className="question-bubble">
                  {couponChallengeQuestion}
                </div>
              )}
              
              {couponChallengeResult && (
                <>
                  <div className={`response-bubble ${couponChallengeResult}`}>
                    {couponChallengeResult === 'success' ? 'ğŸ‰ æŒ‘æˆ°æˆåŠŸï¼' : 'âŒ æŒ‘æˆ°å¤±æ•—ï¼'}
                  </div>
                  <div className={`reward-bubble ${couponChallengeResult}`}>
                    {couponType === 'road_construction' ? (
                      couponChallengeResult === 'success' ? 'âœ… å…æ–¼æš«åœä¸€å›åˆ' : 'â¸ï¸ æš«åœä¸€å›åˆ'
                    ) : couponType === 'gas_station' ? (
                      couponChallengeResult === 'success' ? 'â›½ å…è²»åŠ æ²¹ä¸€æ¬¡' : 'ğŸ’° æŒ‘æˆ°å¤±æ•—è«‹æ”¯ä»˜ä¸€ç™¾å…ƒ'
                    ) : (
                      couponChallengeResult === 'success' ? 'ğŸ  æˆ¿åœ°ç”¢æ¸›å…100å…ƒ' : 'ğŸ’° æŒ‘æˆ°å¤±æ•—è«‹ä»˜åŸåƒ¹'
                    )}
                  </div>
                </>
              )}
            </div>
            
            <div className="challenge-buttons">
              {!selectedCouponChallengeType ? (
                <div className="challenge-actions">
                  <button 
                    className="challenge-complete-btn" 
                    onClick={handleCouponChallengeTypeSelect}
                  >
                    é–‹å§‹æŒ‘æˆ°
                  </button>
                </div>
              ) : (
                <div className="challenge-actions">
                  {couponChallengeResult && (
                        <button className="challenge-complete-btn" onClick={() => {
                          audioManager.play(AudioType.THEME_SELECTION, 0.3);
                          resetCouponChallenge();
                        }}>
                          å®ŒæˆæŒ‘æˆ°
                        </button>
                  )}
                </div>
              )}
            </div>
            
            {selectedCouponChallengeType && !couponChallengeResult && (
              <div className="voice-input">
                <div 
                  className="microphone-icon"
                  onClick={() => {
                    if (isRecording) {
                      stopRecording();
                    } else {
                      startRecording();
                    }
                  }}
                  style={{ 
                    cursor: 'pointer',
                    opacity: isProcessing ? 0.5 : 1,
                    backgroundColor: isRecording ? '#ff6b6b' : '#D2B48C'
                  }}
                >
                  <img src="/src/assets/éº¥å…‹é¢¨.png" alt="éº¥å…‹é¢¨" />
                  {isRecording && <div className="recording-indicator">ğŸ”´</div>}
                  {isProcessing && <div className="processing-indicator">â³</div>}
                </div>
              </div>
            )}
            
          </div>
        </div>
      )}

      {/* æŠ½å¡ç‰‡å‹•ç•« */}
      {isDrawingCard && (
        <div className="card-drawing-overlay">
          <div className="card-drawing-animation">
            <div className="drawing-cards">
              {[...Array(6)].map((_, index) => (
                <div key={index} className="floating-card" style={{
                  animationDelay: `${index * 0.1}s`,
                  left: `${20 + index * 10}%`,
                  top: `${30 + (index % 2) * 20}%`
                }}>
                  <div className="card-back">ğŸ´</div>
                </div>
              ))}
            </div>
            <div className="drawing-text">æ­£åœ¨æŠ½å–å¡ç‰‡...</div>
          </div>
        </div>
      )}

      {/* å–®å­—å¡ç‰‡é¡¯ç¤º */}
      {showWordCard && currentWordCard && (
        <div className="word-card-overlay">
          <div className="word-card">
            <div className="word-card-content">
              <div className="word-title">{currentWordCard.han}</div>
              <div className="word-pinyin">{currentWordCard.tl}</div>
              <div className="word-meaning">{currentWordCard.ch}</div>
              
              <div className="word-illustration">
                {currentWordCard.image ? (
                <img 
                  src={currentWordCard.image} 
                    alt={currentWordCard.han}
                  className="word-image"
                  onError={(e) => {
                    // å¦‚æœåœ–ç‰‡è¼‰å…¥å¤±æ•—ï¼Œé¡¯ç¤ºä½”ä½ç¬¦
                    e.currentTarget.style.display = 'none';
                    const nextElement = e.currentTarget.nextElementSibling as HTMLElement;
                    if (nextElement) {
                      nextElement.style.display = 'flex';
                    }
                  }}
                />
                ) : null}
                <div className="illustration-placeholder" style={{display: currentWordCard.image ? 'none' : 'flex'}}>
                  <div className="illustration-text">ğŸ¨ {currentWordCard.han}</div>
                </div>
              </div>
              
              <div className="word-microphone">
                <div 
                  className="microphone-icon-large"
                  onClick={() => {
                    if (isRecording) {
                      stopRecording();
                    } else {
                      startRecording();
                    }
                  }}
                  style={{ 
                    cursor: 'pointer',
                    opacity: isProcessing ? 0.5 : 1,
                    backgroundColor: isRecording ? '#ff6b6b' : '#8B4513'
                  }}
                >
                  <img src="/src/assets/éº¥å…‹é¢¨.png" alt="éº¥å…‹é¢¨" />
                  {isRecording && <div className="recording-indicator">ğŸ”´</div>}
                  {isProcessing && <div className="processing-indicator">â³</div>}
                </div>
              </div>
              
              {/* é¡¯ç¤ºè¾¨è­˜çµæœ - ç§»åˆ°éº¥å…‹é¢¨ä¸‹æ–¹ */}
              {wordCardSTTResult && (
                <div className="stt-result">
                  <div className="stt-label">è¾¨è­˜çµæœ:</div>
                  <div className="stt-text">{wordCardSTTResult}</div>
                </div>
              )}
              
              {/* é¡¯ç¤ºæŒ‘æˆ°çµæœ */}
              {wordCardChallengeResult && (
                <div className={`challenge-result ${wordCardChallengeResult}`}>
                  {wordCardChallengeResult === 'success' ? 'æŒ‘æˆ°æˆåŠŸï¼' : 'æŒ‘æˆ°å¤±æ•—ï¼'}
                </div>
              )}
              
              {/* æç¤ºæ–‡å­— */}
              {!wordCardSTTResult && (
                <div className="completion-hint">
                  è«‹å…ˆé»æ“Šéº¥å…‹é¢¨ä¸¦èªªå‡ºå–®å­—
                </div>
              )}
              
              <button 
                className="close-card-button" 
                disabled={!wordCardSTTResult}
                onClick={() => {
                audioManager.play(AudioType.THEME_SELECTION, 0.3);
                closeWordCard();
                }}
                style={{
                  opacity: !wordCardSTTResult ? 0.5 : 1,
                  cursor: !wordCardSTTResult ? 'not-allowed' : 'pointer'
                }}
              >
                å®Œæˆ
              </button>
            </div>
          </div>
        </div>
      )}

      {/* éª°å­å€åŸŸ */}
      <div className="dice-area">
        <div className="dice-container">
          {diceValues.map((value, index) => (
            <button 
              key={index} 
              className="dice-button"
              onClick={() => handleDiceClick(value)}
              title={`æ“²å‡º ${value} é»`}
            >
              <div className="dice-face">
                {Array.from({ length: value }, (_, i) => (
                  <div key={i} className="dice-dot"></div>
                ))}
              </div>
            </button>
          ))}
        </div>
      </div>

      {/* éŠæˆ²çµæŸè¦†è“‹å±¤ */}
      {showGameOver && (
        <div className="game-over-overlay">
          <div className="game-over-content">
            <h2 className="game-over-title">
              {winner ? `${winner.name} ç²å‹ï¼` : 'éŠæˆ²çµæŸ'}
            </h2>
            {winner && (
              <p className="winner-message">
                {winner.name} ç¶“éèµ·é»3æ¬¡ï¼Œæ­å–œç²å‹ï¼ğŸ‰
              </p>
            )}
            <button 
              className="close-button"
              onClick={() => {
                audioManager.play(AudioType.THEME_SELECTION, 0.3);
                setShowGameOver(false);
                navigate('/Scoresummary', { 
                  state: { 
                    players: players,
                    gameId: gameHistory.gameId,
                    gameHistory: gameHistory
                  } 
                });
              }}
            >
              æˆç¸¾ç¸½çµ
            </button>
          </div>
        </div>
      )}

      {/* ä½ç½®è©³æƒ…è¦†è“‹å±¤ */}
      {showLocationDetail && currentLocationDetail && (
        <div className="location-detail-overlay">
          <div className="location-detail-content">
            <div className="location-header">
              <h2 className="location-title">{currentLocationDetail.name}</h2>
              <div className="header-right">
                <button 
                  className="close-button"
                  onClick={() => {
                    audioManager.play(AudioType.THEME_SELECTION, 0.3);
                    setShowLocationDetail(false);
                  }}
                >
                  âœ•
                </button>
              </div>
            </div>
            
            <div className="location-info">
              <div className="location-type">{currentLocationDetail.type}</div>
              <div className="location-description">{currentLocationDetail.description}</div>
              
              {/* è·³éæŒ‰éˆ• - æ‰€æœ‰æ ¼å­éƒ½æœ‰ */}
              <button 
                className="skip-button"
                onClick={() => {
                  audioManager.play(AudioType.THEME_SELECTION, 0.3);
                  setShowLocationDetail(false);
                  
                  // ç›´æ¥åˆ‡æ›åˆ°ä¸‹ä¸€å€‹ç©å®¶ï¼ˆæ©Ÿæœƒæ ¼ä¸æœƒè‡ªå‹•åˆ‡æ›ï¼Œæ‰€ä»¥é€™è£¡åªéœ€è¦æ­£å¸¸åˆ‡æ›ï¼‰
                  switchToNextPlayer();
                }}
              >
                è·³é (æ›ä¸‹ä¸€ä½ç©å®¶)
              </button>
              
              
              {currentLocationDetail.challenge && (
                <div className="challenge-details">
                  <div className="challenge-type">{currentLocationDetail.challenge.type}</div>
                  <div className="challenge-title">{currentLocationDetail.challenge.title}</div>
                  <div className="challenge-content">{currentLocationDetail.challenge.content}</div>
                  <div className="challenge-reward">{currentLocationDetail.challenge.reward}</div>
                  <button 
                    className="complete-challenge-button"
                    onClick={() => {
                      audioManager.play(AudioType.THEME_SELECTION, 0.3);
                      if (currentLocationDetail.challenge) {
                        handleChallengeComplete(currentLocationDetail.challenge.type, currentLocationDetail.challenge.reward);
                        setShowLocationDetail(false);
                        // è‡ªå‹•åˆ‡æ›åˆ°ä¸‹ä¸€ç©å®¶
                        setTimeout(() => {
                          switchToNextPlayer();
                        }, 500);
                      }
                    }}
                  >
                    å®ŒæˆæŒ‘æˆ°
                  </button>
                </div>
              )}
              
              {(currentLocationDetail.chance || currentLocationDetail.type === 'reward') && (
                <div className="chance-details">
                  <div className="chance-type">{currentLocationDetail.chance?.type || currentLocationDetail.type}</div>
                  <div className="chance-title">æ©Ÿæœƒå¡</div>
                  <div className="chance-content">è«‹æŠ½å–ä¸€å¼µå¯¦é«”æ©Ÿæœƒå¡</div>
                </div>
              )}
              
              {currentLocationDetail.shortcut && (
                <div className="shortcut-details">
                  <div className="shortcut-description">{currentLocationDetail.shortcut.description}</div>
                  <button 
                    className="use-shortcut-button"
                    onClick={() => {
                      audioManager.play(AudioType.THEME_SELECTION, 0.3);
                      setShowLocationDetail(false);
                      // ç«‹å³åˆ‡æ›åˆ°ä¸‹ä¸€ç©å®¶
                      switchToNextPlayer();
                    }}
                  >
                    ä½¿ç”¨æ·å¾‘
                  </button>
                </div>
              )}
              
              {/* å°æ–¼æ²’æœ‰ç‰¹å®šæ“ä½œçš„æ ¼å­ï¼ˆSTARTã€GOã€ç‰¹æ®Šæ ¼å­ç­‰ï¼‰é¡¯ç¤ºå®ŒæˆæŒ‰éˆ• */}
              {currentLocationDetail.type === 'start' || 
               currentLocationDetail.type === 'go' || 
               currentLocationDetail.type === 'special' && !currentLocationDetail.challenge && !currentLocationDetail.chance && !currentLocationDetail.shortcut ? (
                <div className="completion-details">
                  <div className="completion-message">
                    {currentLocationDetail.type === 'start' ? 'æ­¡è¿ä¾†åˆ°èµ·å§‹é»ï¼' :
                     currentLocationDetail.type === 'go' ? 'é€šéèµ·é»ï¼Œç²å¾—çå‹µï¼' :
                     'ç‰¹æ®Šæ ¼å­æ•ˆæœ'}
                  </div>
                  <button 
                    className="complete-button"
                    onClick={() => {
                      audioManager.play(AudioType.THEME_SELECTION, 0.3);
                      setShowLocationDetail(false);
                      // ç«‹å³åˆ‡æ›åˆ°ä¸‹ä¸€ç©å®¶
                      switchToNextPlayer();
                    }}
                  >
                    å®Œæˆ
                  </button>
                </div>
              ) : null}
            </div>
          </div>
        </div>
      )}

      {/* å„ªæƒ åˆ¸è¦–çª— */}
      {showCouponPanel && (
        <div className="coupon-overlay">
          <div className="coupon-panel">
            <div className="coupon-header">
              <h2 className="coupon-title">å„ªæƒ åˆ¸</h2>
              <button 
                className="close-button"
                onClick={() => {
                  audioManager.play(AudioType.THEME_SELECTION, 0.3);
                  setShowCouponPanel(false);
                }}
              >
                âœ•
              </button>
            </div>
            <div className="coupon-buttons">
              {/* åœ°ç”¢æ ¼å­é¡¯ç¤ºä¸‰å€‹é¸é … */}
              {couponType === 'property' && (
                <>
                  <button 
                    className="coupon-button taiwanese-challenge"
                    onClick={() => {
                      audioManager.play(AudioType.THEME_SELECTION, 0.3);
                      handleWordChallenge();
                    }}
                  >
                    å°èªå¤§å–®æŒ‘
                  </button>
                  <button 
                    className="coupon-button scenario-challenge"
                    onClick={() => {
                      audioManager.play(AudioType.THEME_SELECTION, 0.3);
                      setShowCouponPanel(false);
                      setShowCouponChallengePanel(true);
                    }}
                  >
                    æƒ…å¢ƒæŒ‘æˆ°
                  </button>
                  <button 
                    className="coupon-button no-coupon"
                    onClick={() => {
                      audioManager.play(AudioType.THEME_SELECTION, 0.3);
                      setShowCouponPanel(false);
                      switchToNextPlayer();
                    }}
                  >
                    ä¸ä½¿ç”¨å„ªæƒ 
                  </button>
                </>
              )}
              
              {/* åŠ æ²¹ç«™é¡¯ç¤ºä¸‰å€‹é¸é … */}
              {couponType === 'gas_station' && (
                <>
                  <button 
                    className="coupon-button taiwanese-challenge"
                    onClick={() => {
                      audioManager.play(AudioType.THEME_SELECTION, 0.3);
                      handleWordChallenge();
                    }}
                  >
                    å°èªå¤§å–®æŒ‘
                  </button>
                  <button 
                    className="coupon-button scenario-challenge"
                    onClick={() => {
                      audioManager.play(AudioType.THEME_SELECTION, 0.3);
                      setShowCouponPanel(false);
                      setShowCouponChallengePanel(true);
                    }}
                  >
                    æƒ…å¢ƒæŒ‘æˆ°
                  </button>
                  <button 
                    className="coupon-button no-coupon"
                    onClick={() => {
                      audioManager.play(AudioType.THEME_SELECTION, 0.3);
                      setShowCouponPanel(false);
                      const currentPlayer = players.find(p => p.isCurrentPlayer);
                      if (currentPlayer) {
                        // åŠ æ²¹ç«™ä½¿ç”¨åŸæœ‰çš„æš«åœé‚è¼¯
                        setPlayerSkipped(true);
                        recordGameAction(
                          currentPlayer.id,
                          currentPlayer.name,
                          'move',
                          `${currentPlayer.name} é¸æ“‡ä¸ä½¿ç”¨å„ªæƒ ï¼Œæš«åœä¸€æ¬¡`,
                          { location: currentPlayer.location, skipped: true, couponType }
                        );
                      }
                      switchToNextPlayer();
                    }}
                  >
                    ä¸ä½¿ç”¨å„ªæƒ 
                  </button>
                </>
              )}
              
              {/* é“è·¯æ–½å·¥é¡¯ç¤ºå…©å€‹é¸é … */}
              {couponType === 'road_construction' && (
                <>
                  <button 
                    className="coupon-button scenario-challenge"
                    onClick={() => {
                      audioManager.play(AudioType.THEME_SELECTION, 0.3);
                      setShowCouponPanel(false);
                      setShowCouponChallengePanel(true);
                    }}
                  >
                    æƒ…å¢ƒæŒ‘æˆ°
                  </button>
                  <button 
                    className="coupon-button no-coupon"
                    onClick={() => {
                      audioManager.play(AudioType.THEME_SELECTION, 0.3);
                      setShowCouponPanel(false);
                      const currentPlayer = players.find(p => p.isCurrentPlayer);
                      if (currentPlayer) {
                        // é“è·¯æ–½å·¥å°ˆç”¨æš«åœé‚è¼¯
                          setRoadConstructionSkip(prev => ({
                            ...prev,
                            [currentPlayer.id]: true
                          }));
                          recordGameAction(
                            currentPlayer.id,
                            currentPlayer.name,
                            'move',
                            `${currentPlayer.name} åœ¨é“è·¯æ–½å·¥é¸æ“‡ä¸ä½¿ç”¨å„ªæƒ åˆ¸ï¼Œä¸‹ä¸€æ¬¡è¼ªåˆ°æ™‚æš«åœä¸€å›åˆ`,
                            { location: currentPlayer.location, skipped: true, couponType, roadConstructionSkip: true }
                          );
                      }
                      switchToNextPlayer();
                    }}
                  >
                    ä¸ä½¿ç”¨å„ªæƒ 
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
      )}

      {/* æš«åœæç¤ºè¦–çª— */}
      {showSkipAlert && (
        <div className="skip-alert-overlay">
          <div className="skip-alert-content">
            <div className="skip-icon">â¸ï¸</div>
            <h2 className="skip-title">æš«åœæç¤º</h2>
            <p className="skip-message">{skipAlertMessage}</p>
            <button className="skip-close-button" onClick={() => {
              audioManager.play(AudioType.THEME_SELECTION, 0.3);
              setShowSkipAlert(false);
            }}>
              äº†è§£
            </button>
          </div>
        </div>
      )}

      {/* ç¶“éèµ·é»æ…¶ç¥è¦†è“‹å±¤ */}
      {showPassedStartCelebration && (
        <div className="round-complete-overlay">
          <div className="round-complete-content">
            <div className="celebration-icon">ğŸ‰</div>
            <h2 className="celebration-title">ç¶“éèµ·é»ï¼</h2>
            <p className="celebration-message">{passedStartMessage}</p>
            <p className="celebration-title">çå‹µ500å…ƒ</p>
            <div className="celebration-effects">
              <div className="confetti"></div>
              <div className="confetti"></div>
              <div className="confetti"></div>
            </div>
          </div>
        </div>
      )}

      {/* éŠæˆ²æ­·ç¨‹è¦†è“‹å±¤ */}
      {showGameHistory && (
        <div className="game-history-overlay">
          <div className="game-history-content">
            <div className="history-header">
              <h2 className="history-title">éŠæˆ²æ­·ç¨‹</h2>
              <button 
                className="close-button"
                onClick={() => {
                  audioManager.play(AudioType.THEME_SELECTION, 0.3);
                  setShowGameHistory(false);
                }}
              >
                âœ•
              </button>
            </div>
            
            <div className="history-stats">
              <div className="stat-item">
                <span className="stat-label">éŠæˆ²æ™‚é–“ï¼š</span>
                <span className="stat-value">
                  {Math.floor((Date.now() - gameHistory.startTime.getTime()) / 60000)} åˆ†é˜
                </span>
              </div>
              <div className="stat-item">
                <span className="stat-label">ç¸½å‹•ä½œæ•¸ï¼š</span>
                <span className="stat-value">{gameHistory.actions.length}</span>
              </div>
              <div className="stat-item">
                <span className="stat-label">åƒèˆ‡ç©å®¶ï¼š</span>
                <span className="stat-value">{players.length}</span>
              </div>
            </div>

            <div className="history-actions">
              <h3 className="actions-title">å‹•ä½œè¨˜éŒ„</h3>
              <div className="actions-list">
                {gameHistory.actions.length === 0 ? (
                  <div className="no-actions">å°šç„¡å‹•ä½œè¨˜éŒ„</div>
                ) : (
                  gameHistory.actions.map((action) => (
                    <div key={action.id} className="action-item">
                      <div className="action-time">
                        {action.timestamp.toLocaleTimeString()}
                      </div>
                      <div className="action-content">
                        <div className="action-player">{action.playerName}</div>
                        <div className="action-description">{action.description}</div>
                        <div className="action-type">{action.actionType}</div>
                      </div>
                    </div>
                  ))
                )}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default Monopoly;